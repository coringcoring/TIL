# CHAP 09

* 페이지 부재 빈도(Page Fault Frequency) 가 높다 == 참조한 페이지가 메모리에서 발견되지 않을수록 -> 가상 메모리의 장점이 줄어듦 
    * 이유: 페이지 부재는 해당 페이지를 메모리로 올리기 위해 커널의 개입을 통한 디스크의 입출력을 요구하게 됨 -> 입출력을 발생시킨 프로세스를 대기 상태로 만드는 스케줄링이 가동됨으로써 사용자를 위한 CPU 시간을 상당 부분 커널 실행에 사용하게 됨 -> 사용자는 시스템의 성능을 의심하게 됨 
        * CPU는 가능한 한 사용자 프로그램을 실행하는데 동원되는 것이 사용자로부터 좋은 성능을 가진 시스템으로 인정받을 수 있음 

## 하드웨어의 사용 
* 가상 메모리가 효율적으로 운영되기 위해서는 사상에 걸리는 시간을 최소화 시켜야함 -> TLB 추가의 하드웨어 사용 , 페이지 테이블의 저장을 캐시와 같은 좀 더 빠른 기억 장치에 하는 방법, 테이블의 일부분을 올릴 수 있는 다수의 레지스터를 사용하는 방법 
    * + 사상과정의 각 단계에서 최대한 많은 개수의 레지스터를 동원하여 실행 시간을 최소화하는 것도 필요 
    * 즉, 사상을 빨리 하기 위해 추가의 비용을 들여 필요한 하드웨어를 장착하여 활용 
* 페이지를 관리하기 위한 정보: 참조 비트, 갱신 비트 
    1. 참조 비트(Reference Bit): 해당 페이지가 변경 없이 단순히 참조되었다는 것
    2. 갱신 비트(Modified Bit or Update Bit or Dirty Bit): 내용이 변경되었다는 것을 나타내기 위해 사용됨. -> 비트 기록 위해 추가의 레지스터 사용하기도 함 

## 관리를 위한 다양한 기법들 

### 적재 정책(Fetch Strategy)
* 실행에 필요한 페이지를 언제 메모리에 적재할 것인가를 결정하는 정책 
* 페이지 단위로 나뉘어 있는 전체 프로그램은 디스크에 있음 + 실행되어야할 일부의 페이지는 메모리에 있어야함 -> 이런 페이지들을 메모리에 적재시킬 시점을 정하는데 필요한 정책 
#### 1. 요구 적재(Demand Fetch=Demand Paging)
* 페이지가 참조될 때 적재하는 기법 
    * 적재해야 할 요구가 있을 때 하겠다는 기법
        * 사상 과정에서 찾고자 하는 페이지가 정해지고 이 페이지가 메모리에 없어서(페이지 부재:page fault) 디스크로부터 적재해와야 할 때 
    * 참조되지 않은 페이지는 메모리에 적재될 기회가 없음 
* 참조하는 페이지들만으로 메모리를 사용하므로 메모리에 관한 한 오버헤드가 없음
* 참조 시 페이지 부재일 경우, 이 페이지가 적재될 때까지 해당 프로세스를 대기 상태로 만드는 문맥교환, 디스크와의 입출력 부담이 있게 됨
#### 2. 예측 적재(Anticipatory Fetch=Prepaging(선 페이징))
* 예측을 통해 확률적으로 참조될 가능성이 높다고 판단되는 페이지를 미리 적재시키는 기법
* 예측이 잘 될 경우 페이지 부재 빈도를 낮출 수 있음 
    * 그러나 반대의 경우 예측을 위한 오버헤드+ 참조되지 않을 페이지를 적재한 메모리의 낭비 발생 
* 디스크 상에서 인접한 몇 개의 페이지들을 한 번의 디스크 입출력 때 메모리로 적재시키거나, 프로그램의 시작 시점에서 당장 참조될 것으로 보이는 몇 개의 페이지를 적재시키는 경우에 고려해볼 수 있지만, 실험을 통해 요구 적재가 더 낫다는 것이 밝혀져 있음 -> 예측 적재를 사용하는 경우는 매우 드뭄 

### 배치 정책(Placement Strategy)
* 디스크로부터 가져온 페이지를 메모리의 어디에 적재할 것인가를 결정하는 정책 
* 페이징을 사용하는 시스템
    * 메모리가 페이지의 크기와 같은 프레임으로 이루어져 있으므로 빈 프레임만 발견되면 어떤 프레임에 적재하든 문제가 없고 배치 정책을 따로 신경쓰지 않아도 됨 
* 세그먼테이션을 사용하는 시스템
    * 세그먼트의 크기가 얼마든지 다를 수 있으므로 다양한 크기의 세그먼트를 수용할 수 있는 배치 정책이 요구됨 
    * 7장에서 배운 최초 적합을 비롯한 여러개의 적합 기법 중 하나르 채택하면 됨 

### 할당 정책(Allocation Strategy)와 교체 범위 
* 프로세스들에게 메모리를 얼만큼씩 줄 것인지를 결정하는 정책 (= 페이징의 경우 각 프로세스에게 메모리 프레임을 몇 개 사용할 수 있도록 해 줄 것인가와 같은 말)
* 고정 할당(Fixed Allocation): 프로세스들에게 같은 개수든 서로 다른 개수든 시스템에서 정해놓은 개수를 사용하도록 하고 개수의 변동이 없도록 운영하는 것 
* 가변 할당(Varied Allocation): 실행 도중 프로세스에 부여된 프레임 수에 변동이 있도록 한 것 
* 지역 교체(Local Replacement): 해당 프로세스에게 할당된 프레임 중에서 교체될 페이지를 선택하게 할 때 
* 전역 교체(Global Replacement): 메모리의 모든 프레임들이 대상이 되면 
    * 고정할당을 하게 되면 전역 교체는 불가능 -> 고정 할당을 한다 == 전역 교체를 하지 않는다 
    * 전역 교체에서 프레임이 하나 줄어야 하는 프로세스가 생긴다 == 다른 어떤 프로세스에게는 프레임이 하나 증가 ==> 전역 교체는 가변할당일 수 밖에 없음 

### 교체 정책(Replacement Strategy)
* 메모리에 빈 프레임이 없을 때 적재될 페이지를 위해 적재된 페이지 중 누군가는 자신이 차지한 프레임을 비워줘야 하는 교체 대상이 되어야함 -> 어떤 페이지를 선택할 것인가를 결정하는 정책 
### 최적(Optimal 또는 MIN)기법 
* 방금 교체시킨 페이지가 잠시 후 또 참조된다면 페이지 부재를 겪게됨 -> 시스템 성능의 걸림돌이 됨
* 교체에 있어서 최고의 선택 = 페이지 부재를 최소화하는 것
* 현시점에서 앞으로 가장 오랫동안 참조되지 않을 페이지 -> 미래에 참조될 때까지의 시간이 가장 긴 페이지를 선택하여 교체하는 것 
* 최적기법은 페이지 부재를 최소로 해주지만, 프로세스들이 앞으로 어떤 페이지들을 참조할지를 미리 알 수는 없으므로 현실적으로 구현이 불가능함. 
    * 그러나 구현이 가능한 다른 기법들의 성능을 비교해볼 수 있는 잣대로서 의미를 가짐
* 참조 열 (Reference String): 프로그램의 실행 과정에서 참조될 페이지의 순서 
    * 실제로는 알 수 없지만 기법들의 실행 방식이나 상호 비교를 위해 사용됨 
* 최소의 fault(부재)를 일으킴 
### FIFO 기법 
* 적재된지 가장 오래된 페이지를 교체하는 기법 -> 가장 먼저 적재된 페이지가 교체의 대상이 됨 
* 구현하기 위해 적재된 시간과 순서를 알아야함 => 2가지 구현 방법 
    1. 시간 기록법(Time stamping): 각 페이지가 적재될 때의 시간을 기록 후, 교체 시 이 시간이 가장 오래전인 페이지를 선택하는 것 
        * 시간 기록을 위한 추가의 기억 장소
        * 시간들을 비교하여 가장 오래된 페이지를 찾는데 걸리는 오버헤드가 생김 
    2. FIFO에 어울리는 자료구조 큐를 사용하는 것 
        * 큐에서 상대적인 위치가 적재된 순서를 나타내는 것 
        * 교체의 대상은 항상 큐의 맨 앞(헤드 포인터의 위치)이 되도록 유지, 관리하는 것 
        * 장점: 교체 대상을 바로 알 수 있음 
        * 단점: 큐 내에서 페이지들이 적정 위치에 있도록 자리를 잡아주는데 걸리는 오버헤드 발생 
* 최적에 비해 성능이 저조함 -> 순수한 FIFO 기법만으로는 교체 정책으로 사용되기 어려움 
* 어떤 프로세스가 페이지 부재를 자주 발생시킨다는 것은 충분한 프레임이 할당되지 못했을 경우(충분한 메모리가 주어지지 못한 경우)라고 판단하는 것이 정상적 
    * FIFO 모순(FIFO Anomaly)(=Belady's Anomaly): 하지만 FIFO에서는 부재율을 낮추기 위해 프레임을 더 주었을 경우 오히려 부재율이 올라가는 현상을 발견 (FIFO일때만 발생하는 현상)