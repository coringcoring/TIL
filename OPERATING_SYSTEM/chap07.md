# CHAP 07

## 메모리의 구성
* 메모리를 관리하기 위한 기법은 그 대상이 되는 메모리의 구조에 의존적임 -> 구성이 정해지면 그것에 맞는 적절한 관리 기법이 검토되는 것 
### 메모리 구성과 관련하여 정해져야할 것들 
1. 다중 프로그래밍의 정도(Multiprogramming Degree)
    * 정도(degree): 메모리에 있는 프로세스 개수
    * 정도가 n이라면 각 프로세스에게 얼마만큼의 메모리를 주어야하는가? -> 분할방식 
2. 분할(Partition) 
    * 한 분할 당 한 프로세스 수용 가능 
    * 메모리의 분할을 k개로 할 경우 -> 다중 프로그래밍 정도 최대 k(모든 분할에 프로세스들이 적재되었을 경우)
    * 각 분할의 크기를 어떻게 하느냐에 따라 프로세스들에 부여되는 메모리의 양을 같거나 다르게 해줄 수 있음 
    * 고정(fixed) 또는 정적(static)분할: 메모리의 분할을 미리 해두고 고정적으로 운영할 경우
        * 각 프로세스가 들어갈 분할을 지정하고 항상 그 분할로 적재할 것인지, 아니면 상황에 따라 다른 분할로의 적재도 가능할 것인지를 결정해야 
    * 가변(variable) 또는 동적(dynamic) 분할: 미리 정해두지 않고 프로세스의 크기나 개수에 따라 변동시켜나갈 때 
3. 프로세스에게 메모리를 할당할때 연속적? 혹은 비연속적(Non-contiguous)으로 할지 

* 프로세스: 실행하고자 하는 내용을 담고 있는 프로그램 + 이 프로그램의 정상적인 실행을 위해 시스템으로부터 제공되어야하는 제반 환경 
    * 프로그램: 실행 때 필요한 데이터를 포함, 프로세스를 형성하는 한 축
* 저장 장치에서 바라보는 프로세스의 크기: 프로그램의 크기 

## 메모리의 관리 
1. 적재 기법 (Fetch Strategy) : when?
* 프로세스에게 언제 메모리를 할당해줄 것인가, 언제 프로세스를 메모리에 적재할 것인가? 
    1. 요구(demand) 적재: 적재가 꼭 필요할 때, 적재의 요구가 있을 때 적재 (대부분의 시스템에서 채택)
    2. 예상(anticipatory) 적재: 적재의 요구가 있을 것으로 예상하고 미리 적재 
2. 배치 기법(Placement strategy): where?
* 프로세스들을 메모리 공간 어디에 적재할 것인가? 
    1. 고정 분할 의 경우: 지정된 분할로만 적재할지, 분할을 달리해가며 적재되도록 할지 
    2. 가변 분할의 경우: 적합(fit)기법들 사용 
3. 교체 기법(Replacement Strategy): who? 
* 메모리 공간이 부족할 경우 새로 적재되어야할 프로세스를 위해 메모리에 있는 프로세스 중 어떤 것을 골라 디스크로 내보내고 그 공간을 확보할 것인가
4. 할당 기법(Allocation Strategy)
* 프로세스에게 메모리 공간을 얼마 정도로 줄 것인가를 결정 

## 단일 프로그래밍 
* 단일 프로그래밍: 한 번에 하나의 프로세스만이 메모리에 적재되고 실행이 종료되면, 다음 프로세스가 적재되는 시스템 
* 단점
    * 메모리에서 커널이 차지하는 공간을 제외한 나머지 전부가 하나의 프로세스에게 주어지게 되므로 프로세스가 차지하고 남은 공간은 종료할 때까지 낭비됨 
    * CPU와 다른 자원들의 낭비 또한 많음 
        다중 프로그래밍으로 전환.. 
* 문제점
    1. 메모리의 크기가 적재할 프로그램의 크기보다 크거나 같지 않을 때 -> 오버레이(overlay) 방식 사용해야함 
        * 오버레이: 프로그램의 일부분만을 먼저 적재하여 실행시킨 다음 나머지 부분들을 다시 적재하여 실행을 이어나감 
        * 수동적(manual) 오버레이: 오버레이를 위해서 적절한 시스템 도구(컴파일러, 링커, 로더 등)을 활용하고 프로그램을 적절한 크기로 나누는 등의 부담이 사용자에게 있게 되므로 수동적 오버레이라 부름 
    2. 프로그램의 실행 중 커널 영역을 침범하지 못하도록 해야함 -> 보호 기법 
        * 실행 중인 프로그램이 커널 영역에 속하는 주소에 쓰기와 같은 명령을 함으로써 운영체제를 손상시킬 가능성을 방지하여야 함 
        * 경계 레지스터(Boundary Register)에 커널과 프로그램의 경계 주소 값을 넣어두고, 프로그램이 실행되면서 참조하는 메모리 주소 값이 이 경계 값을 침범하는 경우 트랩으로 실행을 중지시키면 됨 

## 고정 분할에서의 다중 프로그래밍 
* 메모리는 여러 개의 분할로 나누어 놓고, 각 분할에는 하나의 프로세스만을 수용하도록 함으로써 다중 프로그래밍을 구현하는 방식
* 이미 정해진 분할은 고정이므로 크기와 개수가 변하지 않음
* 다중 프로그래밍 정도의 최대치는 분할의 개수와 같음
* 장점: 고정함으로써 관리가 쉽고 편리함, 오버헤드도 적음 
* 단점: 다양한 상황에 유연하게 대처하지 못함, 다중프로그래밍의 정도를 상황에 따라 늘릴 수 없음, 단편화로 인한 메모리의 낭비를 겪게됨 
* 분할의 크기
    * 같게 하면 : 모든 프로세스들에게 같은 크기의 메모리를 주는 결과
    * 현실적으로 프로세스들의 크기가 다양할 것을 예상한다면.. 분할의 크기 역시 다양하게 해두는 것이 유연함 -> BUT 유연함은 복잡도(Complexity)를 동반할 수 밖에 없음 
        * 컴파일될때 주소지정이 이루어지는 경우: 메모리의 할당은 절대(absolute)로더에 의해 언제나 지정된 분할로 들어가도록 됨 
            * 특정 분할로의 쏠림 현상 발생 시 비어 있으나 활용되지 못하는 다른 분할들의 낭비 자초 => 재배치(Rolocatable) 번역과 로더를 사용하여 비어 있는 어느 분할로도 들어갈 수 있도록 하여 메모리 낭비를 줄여야. 
* 분할의 크기는 서로 다르게, 재배치가 가능하도록 해도 발생하는 고정 분할의 문제: 가장 큰 분할보다 더 큰 프로그램의 수용 문제 => 오버레이 방식으로밖에 해결 못함 
* 메모리의 보호: 여러 사용자가 있음으로 해서 단일 프로그래밍 때보다 주의 필요 
    * 사용자-커널 뿐만 아니라 사용자-사용자 사이에도 침범하지 못하도록 해야함 
    * 분할 사이의 경계는 이미 분할할때 알려짐 
    * 실행 중인 프로세스가 자리한 분할의 아래, 위 경계를 두 개의 경계 레지스터에 기록하여 실행하는 도중 참조하는 메모리 주소가 이 값들을 벗어나지 않는다면 실행을 계속하도록 하면 됨 
* 메모리 공간의 단편화(fragmentation)
    1. 내부(internal) 단편화: 분할 내의 낭비 공간. 
        * 이미 고정된 크기로 정해져 있는 분할들에 꼭 맞는 크기의 프로세스들로 채워지기는 불가능 함 -> 분할 내에는 프로세스를 수용하고 남는 자리가 생김 => 프로세스가 나갈 떄까지 낭비됨 
    2. 외부(external) 단편화: 분할의 크기 자체가 워낙 작아서 프로세스들을 수용하지 못한다면 그 분할은 계속 통쨰로 낭비됨 

## 가변 분할에서의 다중 프로그래밍 
* 가변 분할: 분할의 시기, 개수, 크기가 사전에 정해진 바 없이 수용할 때 그 크기만큼 메모리 공간을 할당해줌 
* 장점: 상황에 따라 다중 프로그래밍 정도 조절 가능, 내부 단편화 방지 가능 
* 단점: 관리가 복잡해짐으로써 오버헤드 발생 
* 메모리에서 사용 중인 공간과 빈 공간들에 대한 정보가 필요함 -> 테이블, 리스트와 같은 자료구조로 표현 