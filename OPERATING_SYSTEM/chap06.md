# CHAP 06

* 교착상태(Deadlock): 컴퓨터 시스템에서 자원이 한정적인 상황에서 두 개 이상의 프로세스가 각자 먼저 확보한 자원을 가진 채 상대방의 자원을 필요로 할 경우, 외부로부터의 조치가 없는 한 이들은 아무 일도 못하고 계속 기다려야 함 

## 교착 상태 
* 교착상태가 발생하는 근본적인 원인: 시스템이 가지고 있는 한정적인 자원보다 사용하고자 하는 프로세스들의 요청이 더 많기 떄문 
* 교착 상태: 둘 이상의 프로세스가 각자가 가지고 있던 자원을 보유한 채로 외부적 조치가 없는 한 영원히 그 상태에서 기다리고 있는 상황 
    * 문제점
        1. 해당 프로세스들이 더 이상 실행되지 못하여 사용자들에게 응답해주지 못함
        2. 보유된 자원들이 교착 상태에서 벗어나기 전까지는 전혀 활용되지 못함 
        * 이것들은 모두 시스템의 성능 저하로 이어지게 됨 
    * 무한대기(indefinite postponement)와 차이점 : 무한 대기는 운영체제 상의 규칙이 한쪽으로 치우쳐(biased)있기 떄문에 발생. 오랜 시간 후에라도 무한 대기로부터 벗어나 (외부 조치가 없더라도) 서비스를 받을 수 있음 
### 자원
* 자원: 교착 상태를 일으키는 원인 중 하나 
* 자원의 종류 (소프트웨어의 관점에서)
    1. 하드웨어 자원: 눈으로 보고 만질 수 있는 모든 자원들 
    2. 소프트웨어 자원: 데이터나 메시지 
* 자원의 종류 (선점 가능성에 따라)
    1. 선점 가능 자원 (Preemptible): CPU나 메모리와 같은 자원처럼 한 프로세스에 의해 사용 도중 선점되어 다른 프로세스에게 할당해주었다가 이후 다시 원래의 프로세스에게 돌려주어도 되는 자원들 
        * 사용하는 이유: 다중 프로그래밍의 성공을 위해서 
    2. 선점 불가능 자원 (Nonpreemptible): 선점이 될 경우 자원을 뺏긴 프로세스는 정상적인 진행을 포기해야하는 불이익을 받게 되는 경우의 자원. 선점이 불가능한 자원. 
        * 사용 도중 뻇을 수 없도록 하고 있음 (예시 책 참고)
        * 사용하는 이유: 시스템의 정상적인 진행을 위해서 
* 자원의 종류 (자원이 사용되어지는 방식에 따라)
    * 한 프로세스에게 할당된 자원을 동시에 다른 프로세스가 할당받아 같이 사용할 수 있는가? 
        1. 공유 가능 자원(Sharable): 공유 가능한 프로그램(시스템 프로그램 or 유틸리티 프로그램 등), 공유 데이터 -> 시스템의 모든 자원이 공유 가능 자원이라면 deadlock 발생 안함 (그러나 실제 시스템에서는 배타적 사용 자원이 필요한 경우가 많음)
        2. 배타적 사용 자원(Exclusive): CPU, 메모리, 테이프, 버퍼, 키보드, 모니터 등 
* 자원의 종류 (자원의 속성에 따라)
    1. 순차적 재사용 가능(Serially Reusable): 먼저 할당된 자원이 사용 후 반납되었을 때 자원 자체는 계속 존재하여 또 다른 프로세스에게 할당이 가능할 떄의 자원 
        * 시스템에서 프로세스들이 아무리 사용해도 없어지지 않고 영구히 존재함 
        * CPU, 메모리, 테이프, 하드디스크, 버퍼, 프로그램 등 
    2. 소모성 자원(Consumable): 사용 후 사라지는 자원
        * 시그널(일시적으로 생성되었다가 사용된 후 없어지는), 메시지 등 
### 프로세스 
실행 중인 프로세스가 자원에 대해 취할 수 있는 행동 
1. 필요한 자원에 대한 요청(request)
    1. 요청된 자원이 사용가능(available)하다면 (시스템이 보유하고 있고, 현재 아무도 사용하고 있지 않은 상태의 자원): 이 자원을 할당받아 사용
    2. 이 자원이 다른 프로세스에 의해 사용중이라면: 반납되어질 때까지 대기 상태(blocked)로 기다려야함. 
        * 대기 상태의 프로세스는 자력으로 그 상태에서 벗어날 수 없고 자원의 요청이나 반납과 같은 행동은 더 이상 할 수 없음 
2. 사용이 끝난 자원의 반납 
    * 자원의 요청과 반납은 실행 중인 프로세스가 시스템 서비스를 호출(system call)함으로써 운영체제에 의해 이루어짐 
    * 반납된 자원으로 그 자원 때문에 대기 중인 프로세스를 깨우는 것도 운영체제 
### 교착 상태의 원인 
* 아래 4가지 중 하나라도 부정할 수 있다면 교착 상태는 절대로 발생하지 않음 
1. 자원의 배타적인 사용 [M.E]: 시스템이 보유한 자원 중 배타적 사용이 요구되는 자원 때문에 교착 상태가 발생하는 원인이 됨 -> 상호배제 조건(mutual exclusion condition)
2. 자원의 부분 할당 (partial allocation) [H.W]: 어느 시점에 할당이 불가능한 자원 때문에 이미 확보한 자원들을 소유한 채 대기 상태가 되어버리는 과정을 겪으면서 교착 상태에 빠질 가능성을 높이는 것 -> 보유와 대기 (Hold & Wait) 조건 
3. 자원의 선점 불가능성[No preemption]: 선점 가능한 자원이라면, 자신의 자원을 선점당한 프로세스들은 정상적인 실행을 포기해야함 (선점을 당한다 == 그 자원을 가지고 지금까지 해왔던 일들을 잃게 되는 것) 결국 자원의 선점 불가능성을 고수할 경우 교착 상태의 원인이 됨 -> 비선점(No Preemption) 조건 
4. 자원에 대한 환형 대기 (circular-wait)[Circular w]: (책의 그림, 설명 참고)-> 그래프 이론에서 일컫는 사이클(Cycle)이 있음 -> 환형 대기(Circular wait)

## 교착 상태의 해결 
1. 예방(prevention) 기법: 교착 상태를 아예 발생되지 않도록 하는 것
2. 회피(avoidance) 기법: 역시 프로세스들이 교착 상태를 피해가도록 하는 방법
3. 탐지+복구(detection+recovery) 기법 : 교착 상태가 발생되도록 놓아두었다가 발생 또는 발생 후에 교착 상태를 탐지하여 조치하는 방법. 복구 작업을 수반함 
* 이전에는 교착 상태가 발생하는 경우가 적고 해결하기 위해 필요한 시간과 자원이 많아서 교착상태가 생기면 해당 프로세스를 죽이거나 시스템을 다시 재부팅하여 해결했었음. 
* 이제는 분산 또는 병렬 처리가 일상이 되면서 시스템 내의 프로세스가 많아지고, 자원들은 그 비율만큼 늘어날 수 없으니 결국 한정적인 자원에 대한 프로세스들의 경쟁이 더 치열해짐 -> 교착 상태 발생 가능성이 증가 
* 실시간 시스템의 경우 완료 시간을 맞춰야 하는 프로세스가 교착 상태에 빠지게 되면 안됨 
* => 교착 상태 해결해야함! 
### 1. 예방 기법 (Prevention)
* 발생 원인의 하나를 제거함으로써 교착 상태의 발생 자체를 막도록 한 방법 
1. 자원의 배타적 사용 조건을 배제 : 모든 자원을 공유 가능 자원으로 하여 교착 상태의 발생을 차단 -> 시스템이 보유한 자원 중에는 배타적으로 사용할 수 밖에 없는 자원들이 있음(ex. 프린터, 테이프 장치 등) -> 이 조건을 배제하여 교착 상태를 예방하기는 불가능 
2. 자원의 부분 할당을 배제: 모두 할당(Total allocation) -> 프로세스들은 각자 자신이 필요한 모든 자원을 미리 할당받아 실행을 시작하도록 하는 방법 (실행 도중 자원을 요구하는 일도 x, 대기 상태가 될 일도 x) "All or None" = "All at once"
    * 문제: 필요한 모든 자원이 확보되지 못한 프로세스는 대기 상태가 된다 
        * 일이 시작될 떄 부터 모든 자원이 있어야할 경우란 거의 없음 -> 그 중 몇개만 실제로 사용되는 것이 일반적인 상황 
        * 일부 자원만 확보되면 시작될 수 있음에도 불구하고 모든 것을 할당받을 때까지 기다려야 하고, 할당이 가능했던 일부 자원들은 사용되지 못해 낭비되는 현상이 발생 
        * 모든 자원이 확보되어 실행을 시작할 경우에도 시작 시점에서 할당된 자원들이 실제로 사용되는 시점까지는 역시 낭비되는 것 
    * 단점 
        1. 위의 문제에 의해, 심각한 자원의 낭비가 초래되는 방법임
        2. 무한대기를 겪게 될 프로세스가 발생할 수 있음 
            * 필요한 모든 자원 중 대부분이 할당 가능하지만 그 중 한 두개가 다른 프로세스가 사용 중이라서 대기하던 프로세스에게 시간이 흐른 후 대기의 원인이었던 그 한 두개가 사용 가능해졌다면 -> 그러나 이번에는 아까 할당이 가능했던 자원 중 몇 개가 그 동안 다른 프로세스에게 할당 되어버려 다시 대기를 해야하는 상황이 반복해서 발생한다면 -> 프로세스는 계속해서 실행을 늦출 수 밖에 없게 됨 (무한대기)
3. 자원의 선점 불가능성을 배제: 모든 자원이 선점 가능하도록 할 경우 교착 상태는 발생하지 않을 것 -> 그러나 문제 발생 
    * 일부 자원을 가지고 실행하던 프로세스가 현재 할당이 불가능한 자원을 요청할 경우 자신이 보유하고 있던 자원을 내놓게 함으로써 (=선점 되어버린다) 비선점 조건을 없앰[장점] 
        * 자원을 반납시킨 프로세스는 나중에 필요한 자원을 다시 한꺼번에 요청하여 일을 진행함 
        * 단점 1: 그러나 이는 비정상적인 종료와 함꼐 심할 경우 다시 처음부터 시작해야하는 불이익을 받게 됨 -> 반납되어진 자원들을 사용하여 지금까지 해 왔던 일이 모두 무효가 됨으로써 결과적으로 그 동안 가동되었던 모든 자원들은 사실상 낭비된 결과가 되는 것 
        * 단점 2: 이러한 비정상적인 종료가 자주 발생할 경우 -> 자원의 낭비 , 해당 프로세스는 정상적인 종료를 해보지도 못하고 계속해서 '처음부터 다시' 해야하는 무한 대기도 겪게 될 가능성 높음 
4. 자원의 환형 대기 상황을 배제 : linear-ordering
    * 자원 R1과 R2를 일직선상에 순서를 정해 놓은 후 P1과 P2는 자원의 요청을 순서대로 한 방향으로만 가능 
    * 모든 프로세스는 자신의 실행 동안 필요한 자원들을 실제로 사용할 시기와 상관없이 시스템에 정해놓은 순서에 따라 가져가도록 한 것 
    * 자원들의 순서를 정하고 프로세스들은 이 순서를 지켜 요청하도록 함으로써, 모든 화살표가 한 방향으로만 생성하도록 하여 사이클이 발생될 소지를 없애 교착 상태를 없앤 방법 
    * 단점 1: 순서를 지켜야하기 떄문에 당장에 필요 없는 자원을 먼저 할당받아야 함 -> 자원의 낭비
    * 단점 2: 실제로 필요한 자원을 확보하기 위해 지금 당장 필요 없는 순서상의 하위 자원들을 확보하느라 많은 시간을 보내야하는 프로세스 발생 -> 무한 대기 발생 
* 위의 방법들 모두 자원의 심각한 낭비, 특정 프로세스의 무한 대기 가능성이 존재 
* Realtime 시스템에서는 교착 상태 방지를 위해 이런 단점들을 수용해서라도 prevention 방법을 사용한다 
### 2. 회피 기법 
* 자원의 낭비는 예방 기법보다는 덜하는 여기서도 꽤 발생함
* 대표적인 알고리즘: Dijkstra의 은행가 알고리즘(Banker's Algorithm)
* 안전 상태 (safe state): 시스템에 있는 모든 프로세스가 유한 시간 내에 정상적으로 종료될 수 있는 상태 