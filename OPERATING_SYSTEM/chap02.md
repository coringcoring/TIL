# CHAP 02 

## OS의 목적
* **사용자의 편리성**과 **자원의 효율적 사용** 
* 운영체제 **개발자**에게: 설계, 유지, 보수가 쉽고 적응성이 좋으며 오류 없이 효율적이어야 함
* 운영체제 **사용자**에게: 사용하기 쉽고, 편리하고, 배우기 쉽고, 신뢰할 수 있으며 빨라야함. 

## 몇가지 상식 
### 부팅
* 부팅? : 전원 버튼 > **커널**(운영체제의 일부)이 메모리에 올라와 실행되어 장치들을 준비, **레지스터 초기화** > **사용자의 입력**을 받을 준비를 마친 것 
* **`부트 프로그램`** 또는 **`부츠트랩로더(Bootstrap Loader)`** 
    * 대개 **ROM**에 저장되어 있음. 
    * 전원이 켜지면 무조건 제일 **먼저** 실행됨.
    * 커널을 찾아 메모리에 올린 후 실행시켜주는 역할.
    * PC와 같은 작은 시스템의 경우 ROM에 있는 **부츠트랩 로더**가 더 단순한 기능을 가지고, 커널을 메모리에 올려줄 **부트 프로그램**은 따로 **디스크**에 있어서 **부츠트랩 로더**가 먼저 **부트 프로그램**을 메모리에 올려 실행시키면 **부트 프로그램**이 커널을 올려 실행시키는 방식. 
### 레지스터 (Register)
* **데이터 레지스터**: 연산을 위해 사용됨
    * 메모리에 있는 데이터에 대한 연산 속도보다 레지스터에 있는 데이터 연산 속도 빠름 
* **주소 레지스터**: 데이터나 명령어의 메모리 주소 저장하거나 계산하는데 사용 
    * ex> 인덱스 레지스터: 주소 지정
    * ex2> 세그먼트 포인터/스택 포인터: 해당 포인터 값을 저장하는데 사용 
* 조건 코드 레지스터 
* CPU의 연산을 제어하기 위해 사용되는 레지스터: MBR, MAR, IR, PC 등 
    * 모든 CPU는 현재의 상태 정보를 저장하기 위해 **`프로그램 상태 워드(Program Status Word, PSW)`** 레지스터 가짐. 
        * 여러 가지 조건 코드, 인터럽트 가능/불가능을 표시하는 비트, 현재 실행 모드를 나타내는 비트 등을 포함 
### 명령어 처리 
* 여기서 명령어는 **Instruction**. high language에서의 **statement**를 의미하는 것이 아님. 
* 인터럽트를 빼고 본 명령어 처리 과정 
    1. **명령어 반입**(**Fetch**): 메모리에 있는 명령어 읽어옴 > 처리기에 있는 레지스터로 가지고 옴 
        * 다음에 실행해야할 메모리에 있는 명령어의 주소는 **PC(Program Counter) 레지스터**가 가지고 있음. 
    2. 연산의 종류 파악 후 실행
    3. 하나의 명령어 처리 후 다음 명령어 역시 같은 작업을 반복
    4. 프로그램 실행 종료 

## 인터럽트 (Interrupt)
* **`폴링(Polling)`**: CPU가 일정한 시간 간격을 두고 각 자원(하드웨어 자원- 장치 또는 주변장치)들의 상태를 주기적으로 확인하는 방식 (**수동적**)
    * 자원들은 폴링 신호를 받은 후 자신의 상태, 원하는 바를 CPU에게 알려줌. (상태를 적어놓을 수 있는 곳에 저장시키고 CPU가 폴링할때 이를 읽음.)
    * 문제 
        * 폴링의 간격을 적절히 정해야함
        * 각 자원들은 직전 폴링 이후 변화된 자신의 상태를 다음번 폴링 때까지는 알릴 수 없음 
        * 아무일이 없었는데도 CPU는 폴링에 일정량의 시간을 들여야하는 부담이 생김 
* **`인터럽트(Interrupt)`**: 각 자원들이 **`능동적`**으로 자신의 상태변화를 CPU에게 알림, 거의 대부분의 시스템에서 채택하고 있음. 
    * 하드웨어 인터럽트: 자원들로부터의 인터럽트
        * 처리되는 시기: 현재 진행 중인 명령어 실행을 마친 후 처리됨 
    * 소프트웨어 인터럽트: **`트랩`**(실행 중인 CPU 스스로 자신에게 인터럽트를 해야하는 경우.)이 생기는 경우. 실행 중인 명령어(ex. 0으로 나누는 경우, 다른 사용자 주소를 참조하는 경우 등)에 의해 싱기는 일 
        * **시스템 콜**도 소프트웨어 인터럽트 (입출력을 해야하는 명령어라면 시스템 콜을 통해 **커널 모드**에서 진행해야하므로..)
        * 처리되는 시기: 
            * **오류**의 경우: 바로 프로그램의 종료를 가져오게 됨. 
            * 입출력과 같은 **시스템 콜**: 입출력이 완료되어야 실행 중인 명령어가 완료되고 이어 다음 실행문으로 진행됨. 
    * **`문맥 교환(context switching)`**: 현재 하던 일에서 잠시 다른 일을 해야할 때, 작업대가 같은곳이어야 한다면(CPU) 현재까지의 모양이나 내용(**문맥**: **`프로세스 상태 블록(Process Control Block)`**의 전부 또는 일부분)을 가까운 어딘가에 보관해두었다가(상태 정보를 포함한 **처리기 레지스터**들의 값) 나중에 다시 보관되었던 상태대로 일을 이어나가는 것. 
### 인터럽트 처리과정 
1. 인터럽트 처리 전 
    1. 장치가 인터럽트 신호를 **CPU**에게 보냄. (**CPU**가 명령어를 실행 중이었다면 이 명령어의 실행을 **완료**시키고 인터럽트 신호를 확인)
    2. 인터럽트 처리 루틴 실행 전, 현재 실행 중이던 프로그램이 인터럽트 처리 후 다시 실행될 때를 위해 **현 상태의 정보**(**PSW**, **PC레지스터의 값** 등)를 **시스템 스택**에 저장. 
    3. 인터럽트 처리 시작 **주소**를 **PC**에 넣어 실행시킴으로써 **인터럽트 처리 루틴** 시작 (그 전에, 처리 루틴에 의해 기존 값이 훼손될 가능성이 있으므로 CPU에 있는 **레지스터 값**들을 **저장**해야함)
    4. 인터럽트 처리 루틴 시작 
2. **`인터럽트 처리 루틴`**
    * 인터럽트 직전 
        1. **제어 스택**에 기존의 **PC값**과 **범용 레지스터 값**들을 저장시킴 
        2. **스택 포인터**의 값을 T-5로 변경 
        3. PC에 **서비스 루틴 시작 번지** Y를 넣어주면 **서비스 루틴**이 즉시 시작됨
    * 인터럽트 후 직전
        * **사용자 프로그램**이 다시 실행될 수 있는 환경을 만들어야함.
        1. 스택 포인터의 값(T-5)으로 스택에 보관해 두었떤 값들을 찾아 **범용**, **PC** 레지스터에 복구 
        2. 스택 포인터는 빠진 값만큼 다시 T로 조정
        3. PC에 바뀌어 들어간 **N+1**번지 명령어 실행 -> 사용자 프로그램 실행이 계속될 수 있음! 
3. 인터럽트 처리 후 
* 이전에 저장하였던 레지스터 값들을 다시 **재저장(Restore)**한 후 **PSW**와 **PC** 값들을 원래 자리에 다시 넣어주고 실행 
    * PC에 들어가 있는 값이 인터럽트 이전에 실행 중이던 프로그램에서 다음에 실행할 명령어 위치이므로 자연스럽게 프로그램 실행을 이어나갈 수 있음 
### 중첩된 인터럽트의 처리
1. **`순차처리`** 
    * 중요도가 **동일**한 경우
    * 인터럽트를 처리하는 동안에 발생한 인터럽트는 현재 처리가 끝난 뒤 바로 처리해주는 방식 -> 차례대로 하나씩 처리 
2. **`중첩처리`** 
    * 인터럽트 처리 중 중요도가 더 **높은** 인터럽트가 들어온 경우
    * 현재 처리 중인 인터럽트를 잠시 접어두고 또 다른 인터럽트로 실행을 옮길 수 있도록 하는 방식 

## 기억 장치의 계층적 구조 (Storage Hierachy)
* 기억 장치의 `속도` == `접근시간(Access Time)`
    * 속도가 클수록 가격 `비쌈` 
    * 용량이 클수록 가격은 싸지만 속도가 `느림` 
* 기억 장치의 `가격` == 비트 당 단가 
* 용량도 커야하고, 동시에 처리 속도를 높이기 위해 빠른 저장 장치가 요구되고 있음 -> 용도에 맞게 적절히 저장 장치를 **계층적**으로 구성하는 타협 필요 
* `기억 장치의 계층적 구조`
    ```
        1. 레지스터
        2. 캐시
        3. 주기억 장치 (=메모리)
        4. 전자디스크
        5. 자기디스크
        6. 광디스크
        7. 자기테이프
    ``` 
    * 상위계층에 있을수록 **속도**,**가격** UP
    * 하위계층에 있을수록**용량** UP
    * CPU에 의해 처리되어질 명령어나 데이터가 **위**에 있을수록 시스템 성능이 좋아짐 
    * 평소에는 하위계층에 저장되다가 실행 시에 적당량이 상위계층과 하위계층으로 번갈아 교체되어지면서 **CPU는 최대한 상위계층으로 접근**하도록 만들어 처리 속도를 높임 
    * 프로그램이 CPU에 의해 실행되기 위해서는 반드시 **주기억 장치**에 있어야 -> 메모리에 있는 프로그램의 일부분이 다시 **캐시**로, 그 중에서 실행되어질 명령어는 **처리기 레지스터**에 적재되어 실행과정을 밟게 됨 
    * 캐시, 레지스터는 **하드웨어**의 제어를 받게 됨 , BUT **메모리**는 관리를 어떻게 하느냐에 따라 시스템의 성능을 좌우하므로 **운영체제**의 역할이 중요함 
    * 단점: 계층적 구조의 설계는 계층 간에 데이터가 이동되는 데 드는 부담 (**저장 장치 사이의 입출력에 드는 비용**)을 동반
    * 장점: 상위계층의 접근을 통해 얻게 되는 **처리 시간**의 절약 

## I/O 방식
* CPU의 개입 정도에 따라 분류 
* 입출력 장치에는 **컨트롤러**(`CPU` + 입출력할 데이터를 저장하는 `버퍼`) 존재 
1. **`프로그램에 의한 입출력 (Programmed I/O)`**
    * CPU는 입력을 지시한 후 한 워드가 **컨트롤러**의 **버퍼**에 입력됐는지를 계속해서 확인하도록 하는 방식
        * 입력의 확인 방식: 입출력을 맡고 있는 **시스템 소프트웨어**에 의한 것이므로 => `프로그램에 의한 입출력` 
    * 장점: 입력의 완료를 알리기 위한 **인터럽트** 필요 X 
    * 단점: *CPU가 지속적으로 완료의 여부를 확인해야함* -> CPU는 전체 입출력이 완료될 때까지 다른 작업에 동원되지 못해 낭비됨 
2. **`인터럽트에 의한 입출력(Interrupt-driven I/O)`**
    * 입력을 지시한 후 *한 워드의 입력이 이루어지는 사이*에 CPU는 다른 작업에 활용됨 (다른 프로그램 실행) 
    * 입력 완료 시 **인터럽트**를 통해 CPU에 알려짐 
    * 장점: *프로그램에 의한 입출력* 때의 CPU 낭비를 없앨 수 있음
    * 단점: **버퍼의 크기**에 비해 잦은 **인터럽트** 처리가 필요 -> CPU 낭비 발생 가능 
3. **`메모리에 직접 접근하는 입출력(Direct Memory Access, DMA)`**
    * 인터럽트에 의한 입출력의 단점, 인터럽트 호출 횟수를 줄이고자한 방식 
    * 입출력 작업을 CPU 대신 해줄 수 있는 **`채널`**(`Channel`; `입출력`만 할 수 있는 **프로세서**), **`위성 프로세서`**(**Satellite Processor**) 필요
    * CPU는 입출력할 데이터의 시작주소, 크기 등을 **채널**에게 알려주고 다른 작업에 동원 -> 이때부터 입출력은 **채널**의 주도하에 이루어짐 
    * `블록(Block)`: 시스템에서 한 번의 입출력 단위 
    * 채널은 **블록 단위**로 CPU에게 **인터럽트**를 보내 알리게 됨. (블록 단위만큼 **인터럽트**하면 됨! **인터럽트** 횟수를 줄일 수 있다.)
    * CPU와 채널의 관계
        * **`공유 버스(Shared Bus)`**로 시스템을 구성할 경우, 한 번에 하나의 장치만 버스를 사용하도록 되어 있음 -> 채널이 버스를 사용해 한 블록을 전송하고 있는 동안 CPU는 기다릴 수 밖에 없으므로 전송이 끝나느 잠시 동안 실행이 지연됨-> 그러나 전체적으로 볼 때 입출력에 걸리는 시간은 1번,2번 방식보다 훨씬 앞당겨질 수 있음
        * **`Cycle Stealing`**
            * 우연히 *똑같은 시간*에 CPU와 채널이 *메모리의 접근 요구*를 해올 경우 
                * 메모리는 한 번에 하나의 워드만 접근 가능 
            * 일반적으로 속도가 빠른 CPU가 평소 메모리에 접근 기회를 많이 가지기 때문에 이떄만큼이라도 **채널**에게 기회를 주어 원활한 입출력이 이루어지도록 하는게 공평, 타당하다고 일반적으로 보는 것을 채널이 *CPU의 메모리 접근 사이클을 훔친다*고 해서 **Cycle Stealing**
    * 하드웨어의 구성에 따라 다시 2가지로 분류 가능 
    1. **`독립적인 입출력(Isolated I/O)`**
        * 입출력 장치들이 **입출력 버스(I/O Bus)**를 통해 CPU와 연결되어 있는 경우 
        * 입출력은 입출력을 담당하는 **명령어**를 통해 실행됨 
        * **입출력 버스**를 통해 해당 장치의 지정, 데이터, 입출력을 구분해주는 제어(Control) 값이 전달됨 
        * 장점
            * 속도가 빨라짐
        * 단점
            * 입출력 명령어가 **명령어 집합(Instruction set)**에 추가되므로 제어 로직이 **복잡**해짐
            * 입출력 버스(I/O Bus)를 장착하는데 **추가 비용**이 듬 
    2. **`메모리 주소지정 입출력(Memory-mapped I/O)`**
        * 입출력 장치들이 메모리와 함께 **메모리 버스**에 연결되어 있음 
        * 입출력을 위한 명령어들을 따로 두어 사용하지 않음 -> *메모리에 대한 명령어*(ex. MOVE, LOAD 등)을 사용하여 실제 입출력을 하게됨 
            * 입출력 장치들은 각각 메모리의 번지를 할당받아 그 번지로의 MOVE, LOAD 작업 -> 그 번지에 해당하는 장치로의 **입출력** 
        * 장점: I/O를 위한 **명령어(instruction)**을 추가하지 않아도됨
        * 단점: 만약, 입출력 장치가 2개 있고 주소의 크기가 3bit라면 메모리는 0~5번지를 가지는 크기, 6,7번지는 입출력 장치(for mapping)를 나타내도록 함 -> *이 주소공간만큼의 메모리를 활용할 수 없게 됨.* 

