# CHAP 02 

## OS의 목적
* **사용자의 편리성**과 **자원의 효율적 사용** 
* 운영체제 **개발자**에게: 설계, 유지, 보수가 쉽고 적응성이 좋으며 오류 없이 효율적이어야 함
* 운영체제 **사용자**에게: 사용하기 쉽고, 편리하고, 배우기 쉽고, 신뢰할 수 있으며 빨라야함. 

## 몇가지 상식 
### 부팅
* 부팅? : 전원 버튼 > **커널**(운영체제의 일부)이 메모리에 올라와 실행되어 장치들을 준비, **레지스터 초기화** > **사용자의 입력**을 받을 준비를 마친 것 
* **`부트 프로그램`** 또는 **`부츠트랩로더(Bootstrap Loader)`** 
    * 대개 **ROM**에 저장되어 있음. 
    * 전원이 켜지면 무조건 제일 **먼저** 실행됨.
    * 커널을 찾아 메모리에 올린 후 실행시켜주는 역할.
    * PC와 같은 작은 시스템의 경우 ROM에 있는 **부츠트랩 로더**가 더 단순한 기능을 가지고, 커널을 메모리에 올려줄 **부트 프로그램**은 따로 **디스크**에 있어서 **부츠트랩 로더**가 먼저 **부트 프로그램**을 메모리에 올려 실행시키면 **부트 프로그램**이 커널을 올려 실행시키는 방식. 
### 레지스터 (Register)
* **데이터 레지스터**: 연산을 위해 사용됨
    * 메모리에 있는 데이터에 대한 연산 속도보다 레지스터에 있는 데이터 연산 속도 빠름 
* **주소 레지스터**: 데이터나 명령어의 메모리 주소 저장하거나 계산하는데 사용 
    * ex> 인덱스 레지스터: 주소 지정
    * ex2> 세그먼트 포인터/스택 포인터: 해당 포인터 값을 저장하는데 사용 
* 조건 코드 레지스터 
* CPU의 연산을 제어하기 위해 사용되는 레지스터: MBR, MAR, IR, PC 등 
    * 모든 CPU는 현재의 상태 정보를 저장하기 위해 **`프로그램 상태 워드(Program Status Word, PSW)`** 레지스터 가짐. 
        * 여러 가지 조건 코드, 인터럽트 가능/불가능을 표시하는 비트, 현재 실행 모드를 나타내는 비트 등을 포함 
### 명령어 처리 
* 여기서 명령어는 **Instruction**. high language에서의 **statement**를 의미하는 것이 아님. 
* 인터럽트를 빼고 본 명령어 처리 과정 
    1. **명령어 반입**(**Fetch**): 메모리에 있는 명령어 읽어옴 > 처리기에 있는 레지스터로 가지고 옴 
        * 다음에 실행해야할 메모리에 있는 명령어의 주소는 **PC(Program Counter) 레지스터**가 가지고 있음. 
    2. 연산의 종류 파악 후 실행
    3. 하나의 명령어 처리 후 다음 명령어 역시 같은 작업을 반복
    4. 프로그램 실행 종료 

## 인터럽트 (Interrupt)
* **`폴링(Polling)`**: CPU가 일정한 시간 간격을 두고 각 자원(하드웨어 자원- 장치 또는 주변장치)들의 상태를 주기적으로 확인하는 방식 (**수동적**)
    * 자원들은 폴링 신호를 받은 후 자신의 상태, 원하는 바를 CPU에게 알려줌. (상태를 적어놓을 수 있는 곳에 저장시키고 CPU가 폴링할때 이를 읽음.)
    * 문제 
        * 폴링의 간격을 적절히 정해야함
        * 각 자원들은 직전 폴링 이후 변화된 자신의 상태를 다음번 폴링 때까지는 알릴 수 없음 
        * 아무일이 없었는데도 CPU는 폴링에 일정량의 시간을 들여야하는 부담이 생김 
* **`인터럽트(Interrupt)`**: 각 자원들이 **`능동적`**으로 자신의 상태변화를 CPU에게 알림, 거의 대부분의 시스템에서 채택하고 있음. 
    * 하드웨어 인터럽트: 자원들로부터의 인터럽트
        * 처리되는 시기: 현재 진행 중인 명령어 실행을 마친 후 처리됨 
    * 소프트웨어 인터럽트: **`트랩`**(실행 중인 CPU 스스로 자신에게 인터럽트를 해야하는 경우.)이 생기는 경우. 실행 중인 명령어(ex. 0으로 나누는 경우, 다른 사용자 주소를 참조하는 경우 등)에 의해 싱기는 일 
        * **시스템 콜**도 소프트웨어 인터럽트 (입출력을 해야하는 명령어라면 시스템 콜을 통해 **커널 모드**에서 진행해야하므로..)
        * 처리되는 시기: 
            * **오류**의 경우: 바로 프로그램의 종료를 가져오게 됨. 
            * 입출력과 같은 **시스템 콜**: 입출력이 완료되어야 실행 중인 명령어가 완료되고 이어 다음 실행문으로 진행됨. 
    * **`문맥 교환(context switching)`**: 현재 하던 일에서 잠시 다른 일을 해야할 때, 작업대가 같은곳이어야 한다면(CPU) 현재까지의 모양이나 내용(**문맥**: **`프로세스 상태 블록(Process Control Block)`**의 전부 또는 일부분)을 가까운 어딘가에 보관해두었다가(상태 정보를 포함한 **처리기 레지스터**들의 값) 나중에 다시 보관되었던 상태대로 일을 이어나가는 것. 