# CHAP 10 

## 파일
* 파일: 저장 장치에 연관된 정보의 논리적 저장 단위 
    * 프로세스 간 공유 가능
    * 장기적 보존 가능 
    * 다양한 응용에 맞는 내부구조 가짐 
* 필드 > 레코드 > 파일 > 데이터베이스 
## 파일의 구성 방법
1. 더미(Pile) 파일
    * 일정한 구조를 가지지 않은 채 수집되는대로 저장되는 방식
    * 저장될 데이터들의 크기나 구조가 서로 다를 때 사용하면 저장 공간 아낄 수 있음 
    * 전체 레코드들을 검색해야하는 응용에서 효율적 
    * 그 외에는 적합 x
2. 순차(Sequential) 파일
    * 같은 크기의 레코드들로 구성 + 각 레코드는 알려진 순서로 나열된 같은 개수와 크기의 필드들로 구성됨 
    * 전체 레코드들에 대한 접근이 요구되는 일괄처리에 적합한 구성 
    * 특정 레코드에 대한 읽기나 갱신이 대부분인 대화형 접근에서는 효과적 x 
    * 테이프, 디스크와 같은 저장장치에서 쓰임 
3. 인덱스 순차 파일
    * 순차 파일의 특성 + 파일 인덱스 + 오버플로우 파일 
    * 파일 인덱스: 특정 필드 하나를 키 필드로 한 인덱스를 이용하여 특정 레코드의 접근 시간 줄임 
    * 오버플로우 파일: 추가되는 레코드들은 오버플로우 파일에 모았다가 적정 시기에 원래의 순차 파일과 합병 
4. 인덱스 파일 
    * 완전 인덱스 + 부분 인덱스 
    * 파일 내 레코드들의 위치, 길이에 제약 x 
    * 일괄처리는 필요없되 임의 레코드에 대한 빠른 접근이 요구되는 응용에 적합 
5. 직접(해시(Hash)) 파일 
    * 레코드들이 순차적으로 저장될 필요 없음
    * 키 필드의 값은 해싱을 통해 임의 레코드로 접근할 수 있도록 해줌 
    * 빠른 접근 + 한 번에 한 레코드씩 접근하는 응용에 유용 
## 파일 시스템의 구조 - 논리적 관점
* 논리적 구조?: 사용자에게 파일 시스템이 어떻게 보이는지에 대한 구조 
1. 평면 (1단계) 디렉터리 구조
    * 가장 간단. 파일 시스템 전체에 한 개의 디렉터리가 존재 -> 모든 파일들은 이 디렉터리 안에 저장됨
    * 문제: 같은 디렉터리 안에 있는 파일들은 서로 다른 이름을 가져야 식별 가능 -> 다중 사용자 시스템에서 문제 발생 가능
2. 2단계 디렉터리 구조 
    * 다중 사용자 시스템에서 평면 디렉터리 구조가 갖는 파일 명 부여의 문제 완화 위해 사용자당 하나의 디렉터리 구조 갖게 함 
    * 다른 사용자 디렉터리에 존재하는 파일명은 신경 쓰지 않아도 됨 
    * but 사용자는 더 이상의 하부 디렉터리 가질 수 없음 
3. 계층 (트리) 디렉터리 구조
    * 2단계 디렉터리 구조의 문제를 해결 
    * 루트 디렉터리 
    * 시스템 내에 모든 파일들은 고유한 경로(Path)명을 가짐 
    * 홈 디렉터리 
    * 현재 디렉터리 
4. 비순환 그래프 디렉터리 구조 
    * 다수의 사용자들에 의해 공유될 필요가 있는 경우, 계층구조에서 링크라는 포인터를 사용해 임의의 디렉터리를 다른 디렉터리와 연결시켜 같이 사용될 수 있도록 함
    * 사용자들이 각자의 위치에서 링크를 통해 동일한 디렉터리나 파일로 접근 가능 
5. 일반 그래프 디렉터리 구조 
    * 계층구조에 링크 추가하다보면 탐색을 시작한 디렉터리로 다시 돌아오는 사이클 발생 가능 -> 일반 그래프 구조 
    * 파일의 탐색이 무한루프에 빠지거나, 삭제되어야할 파일이 계속 남아있는 경우 발생 가능 
    * 비순환 구조로 유지되도록 해야함. 링크 추가할때마다 주의하자 

## 파일 시스템의 구조 - 물리적 관점 
### 파일 할당 방식 
1. 연속 할당: 디스크 상에서 연속된 다수개의 블록들을 동원해 파일을 저장하는 방식 
    * 순차처리에는 좋음
    * 빈공간 활용에는 비효율적 
    * 외부 단편화때문에 시간이 흐를수록 충분한 크기의 연속된 블록 찾기 어려워짐 -> 빈공간의 통합작업 필요됨 
2. 체인 할당: 비연속할당. 블록 크기만큼 나누어진 파일의 내용이 체인을 따라 차례로 저장되는 방식 
    * 외부 단편화 안생겨서 공간 활용도 우수 
    * 몇 개의 블록을 연속으로 처리할때 흩어져 있는 각 블록들에 대해 매번 디스크의 다른 부분을 접근해야하는 시간 지연 발생 
3. 인덱스 할당 : 비연속 할당, 연속할당이나 체인 할당에서 발생하는 문제점들 상당부분 해결 가능하여 많이 사용하는 방식 
### 빈 블록들 구현 방법
1. 비트 벡터: 각 블록에 대해 1이면 사용중, 0이면 빈 블록 -> 빠른 검색을 위해 메모리에 둠  
2. 리스트: 디스크 상의 빈블록들을 리스트로 연결, 첫번째 빈블록에 대한 포인터를 커널에 둠 
    * 많은 개수의 빈블록들을 할당할 시 리스트의 변경에 걸리는 시간이 파일의 생성을 느리게 하는 단점 
3. 그룹화 : 각 빈블록은 n개의 빈블록 갖게 함 (n-1개: 빈블록의 번호, 나머지 1개: 다음번 n개의 빈블록 번호를 가지고 있는 블록 번호) -> 리스트 방식보다 연결되는 노드의 수 1/n로 줄임 
4. 인덱싱 : 인덱스 테이블 사용해 디스크 상의 연속된 빈 블록들 당 하나의 인덱스 항목이 설정되어 관리되는 기법, 빈 공간 전체가 하나의 파일 

## 파일에 대한 접근 제어 
1. 패스워드 : 파일마다 패스워드 부여 
    * 패스워드 모두 기억해야하는 부담
    * 어느 정도의 접근 허용할지 각각 패스워드 다시 부여해야하는 부담 
    * 소규모 특정 파일들에 대해서만 부가 기능으로 쓰임 
2. 접근 행렬
    * 그대로 못 씀 -> 희소 행렬때문에 메모리의 낭비 
    1. 전역 테이블: 시스템 전체에 대한 도메인과 파일들 그리고 접근 권한을 순서대로 세 개의 쌍으로 표현하여 전역 테이블에 저장하고 사용하는 기법 
        * 도메인, 파일 개수가 많아질 경우 테이블 크기 너무 커짐 
        * 단순한 나열이라서 비슷한 유형의 도메인이나 파일들을 그룹화할 수 없음 
    2. 접근 리스트: 접근행렬에서의 각각의 열을 리스트로 표현 
        * 쉽고 자연스러운 기법
        * 특정 도메인에 속한 프로세스들이 접근가능한 파일들을 모두 찾아봐야할 때 모든 파일에 대한 접근 리스트를 모두 검색해봐야하는 문제 있음 
    3. 권한 리스트: 접근 행렬의 각각의 행을 리스트로 표현 
        * 프로세스의 중심에서 구축되어 사용자 입장에서 부자연스러워 보임
        * 대부분의 시스템에서 접근 리스트랑 권한 리스트랑 함께 많이 사용함 
    4. 락키방식 : 파일들은 락이라는 비트 패턴, 도메인은 키라는 비트 패턴 리스트 갖게 함 
        * 락이랑 키가 일치되어야 접근 허락 