# CHAP 05

* **`병행(Concurrent)`**: 같이 존재하고 있다
    * ex> **다중 프로그래밍**에서 메모리에 다수의 프로세스가 같이 존재하는 것 
    * 단일처리기의 경우: `논리적 병행성(Logical Concurrency)`
    * 다중처리기의 경우: `물리적 병행성(Physical Concurrency)`
    * 병행 프로세스들은 서로 간에 **`비동기적(Asynchronous)`** => **공유**하는 자원이나 데이터가 있는 병행 프로세스들이 각자 **비동기적**으로 실행되는 것을 제대로 관리하지 못한 채 방치할 경우 문제가 발생함 
* **`병렬(Parallel)`**(!=`병행`): **다중처리 시스템**에서 여러 개의 프로세스가 병렬로 실행됨. 
* => 프로세스들의 **병행성**은 **처리기의 수**와 관계 없으나, **병렬 처리**가 성공하기 위해서는 **병행성**이 전제되어야함 
    * 프로세스가 실행되기 위해서는 **메모리**에 올라와있어야하므로.. 

## 병행 프로세스 (Concurrent Process)
* `공유된` **자원**이나 **데이터**가 있을 경우, 이 자원에 대해 **병행 프로세스**들이 따르는 **룰**이 필요함
    * 룰: *한 번에 한 프로세스만이 접근하도록 하고, 해당 자원에 대해 의도했던 실행을 완료하도록 보장한다* 
    * 책에 있는 예시 참고. count라는 **공유 변수**에 대하여 **시간 종료**나 **우선순위**같은 이유에 의해 CPU를 뺏기더라도 **조작 도중**이었던 공유 변수 count에 대한 접근을 막아야함. 

## 상호 배제 (Mutual Exclusion)
* **`경쟁 상태 (Race condition)`**: 프로세스들이 **공유 데이터**에 대해 서로 접근을 시도하는 상황 
    * 이로 인해 `상호 배제`, `교착 상태(Deadlock)`, `기아(Starvation)` 문제 발생 
* 임계 자원(Critical Resource), 임계 영역 (Critical Section)
    * **`임계 자원(Critical Resource)`**: 두 개 이상의 프로세스가 동시에 사용할 수 없는 자원
    * **`임계 영역(Critical Section)`**: 임계자원에 접근하고 실행하는 **프로그램** 내의 **코드** 부분 
* **`상호배제`**: 한 번에 하나의 프로세스만이 **임계영역**에 들어가야(실행되야) 하는 것 
* 임계영역의 성공적인 실행을 위해 **상호 배제**는 지켜져야함
* 임계영역에 있지 않는 프로세스가 다른 프로세스의 임계영역 진입을 막아서도 **x** 
* **비어있는** (아무도 실행하고 있지 않은) **임계영역**에 대한 진입은 바로 **허용**하되, 특정 프로세스의 진입 시도가 계속 **무산**되어 **기아**를 겪지 않도록 해야함 
* 임계영역에 들어가고자 하는 프로세스는 임계영역 내에 다른 프로세스가 있다면 기다려줘야하고, 임계영역이 비어있다면 진입하여 다른 프로세스가 들어오지 못하도록 해야함 
* 임계영역을 벗어날때는 자신이 나오는 사실을 알려 다른 프로세스가 들어올 수 있도록 해야함 
* **상호배제의 성공** 여부를 결정짓는 것: **임계영역**을 진입할때와 나올때 꼭 해야하는 일을 잘 구현하여 프로그램 내 **임계영역** 앞뒤에 적절하게 코딩해주느냐 가 결정 

## 상호배제를 위한 소프트웨어 기법들 
* **`소프트웨어 기법`**들: **병행**하는 프로세스들에게 **상호배제**를 책임지도록 한 것 
    * **운영체제**의 지원 없이 프로세스들 간에 자신의 **프로그램**에서 **임계영역 앞뒤**로 적절한 **코딩**을 통해 **상호배제**를 해결하는 방식 
        * 단점: **CPU 낭비** 가능, **프로그래머의 실수**로 인한 **오류** 발생 가능 
* **`parbegin/parend`** 구조 
    ```
    parbegin
        statement_1;
        statement_2; 
        ...
        statement_n;
    parend
    ```
    *` parbegin`과 `parend` 사이에 존재하는 **n개의 문장**들이 **동시에** 수행될 수 있음 
    * **단일처리기** 시스템의 경우: 문장의 수행 순서를 **임의로 진행**해도 좋다는 의미 
    * **다중처리기** 시스템의 경우: 각 문장을 **병렬**로 실행하겠다는 의미 
        => 문장들의 **나열 순서**는 아무 **의미x** 
    * *병행 프로세스 간의 **실행 속도**와 **임계영역**을 들어가고자 하는 **횟수**의 **차이**는 얼마든지 날 수 있음*
### 몇가지 미완성 시도들 
1. 첫번째 시도 
    ```
    Begin /*main*/
        int turn=0;
        parbegin
            P0;
            P1;
        parend
    End
    ```
    ```
    P0:
    While (true) do
        .
        .
        While (turn ==1); /* do nothing*/
        <critical section>;
        turn :=1; 
        .
        .
    endwhile;
    ```
    ```
    P1:
    While (true) do
        .
        .
        While (turn ==0); /*do nothing*/
        <critical section>;
        turn :=0;
        .
        .
    endwhile; 
    ```
    * 허점 
        1. turn의 초기값이 0으로 되어있으므로 임계영역의 **첫번째 진입**은 **P0**만 할 수 있음 -> **임계영역**이 **비어있을** 경우 **진입**을 원하는 프로세스를 **방해**해서는 안된다는 원칙 **위배**
        2. 임계영역의 진입이 **turn 값**을 바꾸어줌으로써 가능하므로 P0와 P1은 한번씩 **번갈아가며** 진입이 가능, 누구나 **연속해서 두 번 이상** 진입 **불가능** 
            * 프로세스 각자의 진입을 원하는 횟수는 **다를 수 있음**
            * 상대적으로 **많은 횟수**의 진입이 요구되는 프로세스는 그 횟수 만큼 상대 프로세스가 **임계영역**을 진입해주어야함 (만약 상대 프로세스가 먼저 종료될 경우 자기도 임계영역에 들어갈 수 없는 문제 발생) 
            * 상대적으로 **실행 속도가 느린** 프로세스의 속도에 **의존적**일 수 밖에 없음 
2. 두번째 시도 
    ```
    boolean flag[0], flag[1]; 
    void P0(){
        while(true) {
            .
            .
            while(flag[1]); 
            flag[0]=true;
            <critical section>;
            flag[0]=false; 
            .
            .
        }
    }

    void P1(){
        while(true){
            .
            .
            while(flag[0]); 
            flag[1]=true;
            <critical section>;
            flag[1]=false; 
            .
            .
        }
    }

    void main(){
        flag[0]=false;
        flag[1]=false;
        parbegin
            P0;
            P1;
        parend 
    }
    ```
    * 나아진점: 첫번째와 달리 **임계영역 최초 진입의 제한**이 사라짐, 상대적으로 **많은 횟수**의 진입이나 상대 프로세스가 **먼저 종료**되어도 **임계영역**에 진입이 가능 
    * 허점
        1. 각자의 **flag를 true로 만드는 작업**이 **while문 다음**에 있어서 발생하는 문제
            * 만약 P0에서 flag[1] 검사 후 while문 벗어난 다음 flag[0]을 true로 만들기 전에 CPU를 P1에게 뺏기게되면 P1은 while문을 지나 임계영역에 들어가게되고 실행 도중 다시 P0에게 CPU가 넘어가게 되면 P0는 이전에 중단되었던 작업(flag[0]을 true로 만드는 작업) 진행 후 임계영역에 진입 -> *둘 다 임계영역에 존재하게 되어버림* 
            * **다중처리**의 경우: 동시에 while문 검사한 후 둘 다 각자 flag를 true로 만든 다음 임계영역으로 진입할 수 있기 때문에 *상호배제가 지켜지지 않게됨* 
3. 세번째 시도
    * 위의 코드에서 flag를 true로 만드는 작업이 **while문 앞**에 오는것 
    * 발생하는 문제: P0가 flag[0]을 true로 만든 다음 CPU가 P1에게, P1은 flag[1]을 true로 만든 다음 while문에서 맴돌다가 다시 CPU는 P0에게, P0역시 while문에서 맴돌게 되는 현상 발생 가능 => *둘 다 임계영역에 진입하지 못하게됨* **`데드락(DeadLock)`**
4. 네번째 시도 : 두 프로세스의 **속도**가 교묘히 맞물렸을 때 둘 다 **임계영역**에 진입하지 못하게되는 현상 **`라이브락(Livelock)`**
    * 그러나 속도의 차이가 조금이라도 어긋나는 시점이 오면 하나가 임계영역에 들어갈 수 있음 
### 성공적인 기법들 
* **`Dekker의 알고리즘`**
    * 단점: 이해하기 어렵고 정확성을 증명하기 까다로움
* **`Peterson의 알고리즘`**
    * Dekker 알고리즘의 단점을 해결 
        ```
        void P0(){
            While (true){
                flag[0]=true;
                turn =1; 
                While (flag[1]&& turn==1); /*do nothing*/
                <critical section>;
                flag[0]=false;
                <remainder>; //임계영역이 아닌 해당 프로세스 고유의 일 
            }
        }
        ``` 
### n 프로세스 간의 상호배제를 위한 소프트웨어 기법들 
* **`n개의 프로세스들을 대상으로 하는 상호배제 기법`**들..
1. **`Dijkstra의 알고리즘`** : 그러나 `무한 대기`가 발생할 수 있음
2. **`Knuth의 알고리즘`**: `지연 시간`이 커지는 단점이 있음 
3. **`Eisenberg와 Mcquire의 알고리즘`**: `유한 시간` 내에 `임계영역`으로의 진입이 보장됨 (`성공`)
4. **`Bakery 알고리즘 (=Lamport의 알고리즘)`**
    * 원래 분산 시스템용으로 소개되었음
    * n개의 프로세스들을 대상으로 하는 상호배제 기법으로도 유용함 
    ```
    do{
        choosing[i]=true;
        number[i]=max(number[0],number[1],...,number[n-1])+1;
        choosing[1]=false;
        for(j=0;j<n;j++){
            while(choosing[i]); 
            while((number[i]!=0) && ((number[j],j)<(number[i],i))); 
        }
        <critical section>;
        number[i]=0;
        <remainder>; 
    }while(1);
    ```
    * 장점: `number[i]=0`으로 초기화해줌으로써 다른 프로세스에게 **임계영역의 진입 기회**를 주게됨-> `번호값`에 의해 `차례`가 정해지므로 특정 프로세스의 **무한 대기는 발생 x** (`기아 x`)

* 소프트웨어 기법들의 단점
    * **운영체제**의 특별한 지원 없이, **프로세스 간 협력**을 통해 상호배제를 실현하는 것이므로 실행 시의 **부하**가 큼. 
    * **실수**로 인한 **오류의 가능성**도 높음 
    * **`바쁜 대기(Busy Wait)`** 또는 **`스핀락(SpinLock)`** 발생: 임계영역의 `중복 진입`을 막기 위해 `while문`을 계쏙 맴도는 것은 CPU는 가동은 하였으나 유용한 곳에 쓰지 못한 채 낭비하는 결과를 초래함 
* 임계영역에 대한 실행은 *"한 번에 한 프로세스만 하겠다"* 라는 의미 => *"차례대로"* => **`동기화(Synchronization)`**