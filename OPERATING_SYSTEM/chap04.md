# CHAP 04

## 스케줄링?
* **``스케줄링(Scheduling)``**: 일반적으로 여러 `프로세스`들이 번갈아 사용해야 하는 자원이 있을 경우, 주어진 시점에서 어떤 프로세스가 이 자원을 사용할 수 있도록 해 줄 것인가를 결정하는 것 
    * 그 자원이 CPU일 경우 -> `"CPU 스케줄링"` = **(CPU) 스케줄링** 
* 스케줄링의 프로그램도 `커널`에 포함됨 

## 스케줄링의 단계
* `수행 단계`에 따라.. 
1. **`장기 스케줄링(Long-term)`** (=`작업 스케줄링(Job Scheduling)`)
    * 어느 작업을 `커널`에 등록시켜 `프로세스`를 만들어 줄 것인가를 결정 
    * `일괄처리 시스템`의 경우: 새로 작업이 들어오면 먼저 `디스크`에 놓아둔 채 `일괄처리 큐`에서 대기하도록 한 후 `장기 스케줄러`를 거쳐 `프로세스`가 되도록 함
    * `시분할`의 경우: `사용자의 접속 시도`를 허용할지 말지를 결정하는 단계라고 볼 수 있음 
    * 즉, 이 단계는 요청된 일을 `프로세스`로 만들어 시스템에 알려진 일거리로 추가하느냐를 결정하는 것 -> **`다중 프로그래밍의 정도(Multiprogramming degree)`**를 조절하는 역할 
    * 수행 횟수가 **적음**
    * 대부분 `FIFO 방식` 사용 
    * 좀 더 복잡한 스케줄링 방식 동원하는 경우 -> **계산 위주의 프로세스**와 **입출력 위주의 프로세스** 수를 적절히 맞추기 위해 프로세스의 **성격**을 반영하는 **우선순위 방식** 사용 가능 
2. **`중기 스케줄링(Medium-term)`**
    * `보류 상태`의 프로세스들 중 어느 프로세스에게 `메모리`를 할당해줄 것인가를 결정 
        * `스왑아웃`된 프로세스들 중 어떤 프로세스를 다시 `스왑인`(or `Resume`)할 것인가를 결정 
3. **`단기 스케줄링(Short-term)`**
    * `준비 상태`에 있는 프로세스들 중에서 어느 프로세스에게 `CPU`를 할당할지를 결정 
        * `프로세스 스케줄러` OR `디스패처(Dispatcher)`에 의해 수행됨
    * 일반적으로 부르는 프로세스 스케줄링이 대부분 단기 스케줄링을 뜻함 
    * **입출력**, **시간 종료 인터럽트**, **시스템 콜** 등과 같은 다양한 이유에 의해 가동됨
        * 횟수가 **잦음** -> 한 번 실행에 드는 시간을 **줄이는** 것이 중요 

## 스케줄링의 목적과 기준
* 어떤 것들이 시스템의 성능을 평가하는 잣대가 될 것인가?
1. **`응답시간(Response Time)`** -> `사용자`의 관점에서..
    * `응답시간`?: 프로세스의 요청에 대해 시스템이 *최초로* **출력**을 내주기 시작할 때까지 걸린 시간. 
        * 사용자의 입장에서 가장 직접적으로 시스템의 성능을 느낄 수 있는 지표 
    * `일괄처리`의 경우: `요청`으로부터 `결과`를 돌려받는 데까지 걸린 시간 -> `반환 시간(Turn-around Time)`이 지표가 됨 
        * 요청한 일이 얼마 후 쯤에는 완료될 수 있을 것이라는 `예측가능성 (Predictability)` 등도 지표로 활용될 수 있음 
2. `처리량(Throughput)`, `활용도(Utilization)` ->`시스템`의 관점에서..
    * `처리량`?: `단위 시간`에 완료되어진 `프로세스`의 개수 
    * `활용도`?: 주어진 시간 동안 특정 `자원`이 실제로 `가동`된 시간의 비율 
3. `공평성(Fairness)`: 가능한 한 `CPU 사용 시간`을 공평하게 나누어주어야 하는 것 
    * 특정 프로세스가 `장기간` CPU를 받지 못하게 되는 경우 피함
    * 시스템에 있는 여러 `자원`들은 가급적 `균형 있게` 사용되도록 해야함 
* `대화형 시스템`에서는 `응답시간`이 가장 중요한 지표/`일괄처리 시스템`에서는 `처리량`이 가장 중요한 지표 
    * `처리량`을 높이기 위해 `응답 시간`이 길어질 수도 있음 -> 지표들이 **상충**됨 -> 시스템을 사용하는 **환경**, **목적**에 맞는 지표를 치중해서 스케줄링을 해주어야함 
        * 어떤 경우에 지표들이 상충?
            * 프로세스들에게 **빠른 응답 시간**을 주기 위해 **CPU 스위칭**(**스케줄링**)을 자주 할 때 -> 그때마다 **문맥 교환**이 필요-> CPU 시간의 상당 부분이 **문맥교환**에 사용됨 => **사용자 프로세스**를 실행해 줄 시간이 줄어들어 전체적으로 **처리량**이 **감소** 
            * 주어진 기간 동안에 많은 프로세스를 처리하여 **처리량**을 높이려고 **수행시간**이 **짧은** 프로세스들을 주로 처리 -> 수행 시간이 **긴** 프로세스는 처리가 늦어져 **응답시간**이 **길어짐**
* 스케줄링을 만들 때 고려해야할 기준 
    1. 스케줄링의 대상이 되는 `프로세스`의 `성격` 
        1. `연산 위주(CPU bound 또는 Computation-bound)` 프로세스 : CPU를 사용하는 `연산`이 `입출력`에 비해 상대적으로 많을 때 
        2. `입출력 위주(I/O-bound)` 프로세스 : 그 반대의 경우
        * 목적에 따라 어떤 종류의 프로세스를 더 우대할 지를 생각해야. 
    2. 시스템이 사용될 `환경`에 따라 `응답시간`을 우선으로 할지, `처리량`을 우선으로 할지    
        * 특정 프로세스에게 우선적으로 빠른 응답 시간을 보장해야하는 경우가 있다면 이를 가능케하는 `기능`이 있어야함 
        * 프로세스의 크고 작음(`크기`=`완료` 때까지 요구되는 `CPU 실행 시간`)에 따라 어떤 것을 더 우선적으로 처리해야할지의 `기준` 가지고 있어야함

## 스케줄링 기법들 
* 스케줄링이 가동되어야하는 시기
    1. 프로세스가 `실행 상태`-> `대기 상태` (EX. `입출력 요청`) -> `비선점 방식` 
    2. 프로세스가 `실행 상태`-> `준비 상태` (EX. `시간종료와 같은 인터럽트` 발생) -> `선점 방식` 
    3. 프로세스가 `대기 상태`-> `준비 상태` (EX.`입출력 종료`) -> `선점 방식`
    4. 프로세스가 수행을 마치고 `종료`될 때 -> `비선점 방식`
* 구분
    1. **`비선점(Nonpreemptive)방식`**: 한 프로세스가 `CPU`를 할당받았을 때 `CPU`를 스스로 반납할 때까지 `계속 사용`하도록 허용하는 방법
    2. **`선점(Preemptive)방식`**: `CPU`를 할당받아 실행 중인 프로세스로부터 `CPU`를 `선점`(빼앗는다)하여 다른 프로세스에 할당할 수 있는 방식, 실행되는 프로세스의 의지와 상관없이 `CPU`를 뺏길 수 있음  
        * EX> 현재 CPU를 할당받아 실행 중인 프로세스보다 우선순위가 높은 프로세스가 도착하면 현재 프로세스의 실행을 중단하고 우선순위가 높은 프로세스에게 CPU를 할당하는 방법 
### FCFS(First Come First Service) 스케줄링 
* = `FIFO(First in First out)`
* `준비 큐`에 먼저 도착한 `프로세스`에게 먼저 `CPU`를 할당해 주며, `CPU`를 할당받은 프로세스는 스스로 `CPU`를 반납할 떄까지 `CPU`를 독점하여 사용하는 **비선점 방식** 
* 가장 `단순`한 형태로서 실제 시스템에서 바로 사용되기는 힘들지만 다른 스케줄링 기법의 `보조 장치`로서 활용 가능 (`우선순위`가 `동일`할 경우의 차선책)
* 단점
    * 프로세스가 CPU를 `독점`하여 사용하기 때문에 아주 `긴` 프로세스가 실행될 경우 오래 기다려야하므로 `대화식 시스템`에 적합하지 않음
        * **평균 응답 시간**이 길어지는 단점
* 장점
    * **준비 상태 프로세스**들의 개수, 크기 짐작 가능하다면 각각의 프로세스들이 언제쯤 실행될 수 있을지를 **예측 가능** 
    * **도착 순서**만이 실행 순서를 결정짓는다는 점에서 **공평함**
* 나머지 부분 책 참고 
### SPN(Shortest Process Next) 스케줄링 
* = `SJF(Shortest Job First)` 스케줄링 
* `준비 큐`(`큐`만으로 안됨. `위치`를 변경시켜주어야하므로 다른 data structure 사용해야)에서 기다리고 있는 프로세스 중에서 `CPU 요구량`이 가작 적은 것을 먼저 실행시켜 주는 **비선점 방식**
* 장점
    * 평균 응답 시간 **최소화** 가능
    * 실행해주어야 할 **프로세스** 수가 **충분**하다고 하면, `처리량`에 관한 한 매우 훌륭한 성능을 보임 
    * **FCFS**에 비해 빠른 응답 시간 기대 가능   
* 단점
    * **`무한 대기 현상`** 발생 가능 : 실행 시간이 긴 프로세스가 **CPU**를 할당받지 못하고 계속해서 대기하는 현상 
        * 무한대기 가능성을 낮추는 방법-> **`에이징(Aging)`**: 기다린 시간만큼 `우선순위`를 높이는 것 
    * **긴 프로세스**일수록 **편차**가 커져 `예측가능성`은 오히려 떨어질 것
    * 각 프로세스들의 `크기` (실행 시간의 길고 짧음)를 실행 전에는 정확히 알 수 없음에도 불구하고 그 `크기`를 가지고 **스케줄**을 해야함 
        * 해결 방법: **`지수 평균 방법 (Exponential Averaging)`**[`프로세스의 크기`를 **실행 전**에 **추정**해보는 것]-> 비슷한 **환경**에서 **반복적**으로 실행되어지는 프로세스들에 대해서는 적용할만 함 (이전의 **실행**되었을 때의 크기와 그때의 **추정** 크기로 **지금** 실행되어질 크기를 짐작) 
### SRT(Shortest Remaining Time) 스케줄링
* **SPN**을 `선점 방식`으로 운영 
* **준비 큐**에서 완료까지 남은 **CPU 요구량**이 가장 짧은 것을 **먼저** 실행시켜주는 방식. 
* 실행 도중 남은 실행 시간이 더 적은 프로세스가 준비 큐에 들어올 경우 현재 실행 중인 것을 **중단**하고 새 프로세스에게 **CPU**를 할당하는 **`선점 방식`** 
* 새로 도착하는 프로세스의 실행 시간 크기는 완료까지 남은 시간과 **같음** 
* CPU를 할당받아 실행한 만큼 **완료**까지 **남은 시간**(`remaining time`)은 줄어들 것 
* 단점: **SPN 방식**의 단점과 함께 완료까지 남은 실행 시간의 **계산**, 실행 시간이 짧은 프로세스가 **자주** 도착할 경우의 **잦은 선점**으로 인한 **문맥 교환**의 부담 
* **반환 시간**을 놓고 따져보면 **SRT**가 **SPN**보다 우수 
* SPN보다 **평균 완료(응답) 시간**이 짧아서 더 좋은 것으로 보일 수도 있으나, SRT는 남은 시간의 계산과 함께 SPN보다 더 많은 **문맥교환**이 요구되어 실제로는 **평균 응답 시간**이 좀 더 길어질 수 있음 
    * SPN을 수정하여 **평균 완료(응답) 시간**을 줄이는 방법: **`Future knowledge 스케줄링`** 
        * 가까운 미래에 도착하게 될 프로세스의 정보를 알 수 있다면? 
        * 1초만 기다리면 5와 2의 크기를 가진 프로세스가 도착한다는 것을 알 수 있다면 처음에 P1으로 CPU를 할당하는 대신 1초 동안 기다렸다가 **SPN**을 적용함 -> 처음 1초동안 **CPU를 쉬게 하여** 더 우수한 결과를 얻어낼 수 있음 
    * **SRT 스케줄링**을 위한 **`임계값(Threshold Value)`**를 정하여 프로세스의 남은 시간 차이가 **임계 값**을 넘지 않을 경우 선점되지 않도록 함 
        * 조금만 있으면 완료될 프로세스가 cpu를 받아 실행 중인데 더 짧은 프로세스가 준비 큐에 들어왔을 때 
        * 남은 시간이 꽤 긴 프로세스가 cpu를 받아 실행 중인데 새로 들어온 프로세스가 남은 시간이 더 짧지만 그래도 꽤 긴 프로세스가 들어왔을 때 
        * -> 임계값보다 작으면 **문맥교환**을 하지 않고 **그대로 실행**
        * -> 임계값보다 크면 **문맥교환**을 함 
### HRRN(Highest Response Ratio Next) 스케줄링
* `SPN`, `SRT`의 약점인 수행 시간이 **긴** 프로세스의 `무한 대기 현상`을 방지하기 위한 기법 
* **준비 큐**에 있는 프로세스들 중 `응답률(Response Ratio)`가 가장 높은 프로세스에게 **높은** `우선순위`를 주며, `비선점 방식` 
    * `**응답률(Response Ratio)**`: **프로세스의 크기**(**CPU 요구량**)에 대한 **대기 시간**의 비율 
        * (`대기시간`+`CPU 요구량`) / `CPU 요구량` 
* 장점
    * 프로세스가 기다리는 시간이 길어질수록 **우선순위**가 높아짐 (**대기 시간**을 **Aging**하여 **우선순위**에 반영한다는 의미) -> 수행시간이 긴 프로세스도 머지 않아 CPU를 할당받을 수 있게 됨 
    * **분모**인 **CPU 요구량** -> **분모**가 클수록 -> **CPU 요구량**이 큰 프로세스일수록 우선순위가 **낮음** -> **평균 응답(완료) 시간** 단축 가능 
    * 실행되지 못할 동안 **대기 시간**은 계속 **증가** -> **스케줄링**을 할때마다 준비 큐의 모든 프로세스들에 대해 **응답률**을 계산하여 CPU를 줄 프로세스를 선정 -> 선택된 프로세스는 자발적으로 CPU를 내놓지 않는 한 **실행 계속 가능**
### 라운드 로빈(Round-Robin) 스케줄링
* `Time sharing(시분할)`의 대표적인 스케줄러
* `FCFS` 스케줄링을 기반으로하여 CPU를 할당하되, 각 프로세스는 **`시간 할당량(Time Quantum)`** (한 번에 쓸 수 있는 CPU `시간` 크기)이 지나면 `시간 종료 인터럽트`에 의해 CPU를 뺏기는 `선점 방식` 
    * CPU를 뺴앗긴 프로세스는 `준비 큐`의 `끝`에 들어감 
    * 준비 큐 `앞`에 있는 프로세스가 CPU를 할당받게 됨 
* `시간 할당량`의 크기에 따라 시스템의 성능이 크게 달라질 수 있음 
    * 시간 할당량이 **크다** -> **FCFS 스케줄링** 방식과 같아지게 됨
    * 시간 할당량이 **작다** -> **문맥교환**이 자주 발생 -> **문맥교환**의 **오버헤드**가 커짐 
    * 시간 할당량의 크기는 10~100밀리초가 적당 
* `**가상(Virtual) 라운드 로빈**` 
    * `Original Round Robin`: **연산 위주**의 프로세스가 **입출력 위주**의 프로세스보다 더 우대받고 있음 
    * **연산 위주**: 주어진 **시간 할당량**을 모두 소진하고 큐의 맨 **뒤**로 들어감 
    * **입출력 위주**: 대부분 시간 할당량을 남긴 채 **입출력**을 발생시킨 다음 **입출력**이 완료되면 당시 **남겨진 시간 할당량** 부분을 보상받지 못한 채 큐의 맨 뒤로 들어감 
        * -> 보완 방법 in **`Virtual Round Robin`**: **입출력을 마친 프로세스**가 들어가는 **준비 큐**를 따로 하나 두고 **우선순위**를 더 높게 하되, 이 큐에서 CPU를 받을 때는 이전 **입출력**을 발생했을 때 쓰지 못하고 **남긴** **시간 할당량**만큼 주도록 하는 방법 
* 장점 
    * `FCFS` 기법에서처럼 한 프로세스가 `CPU`를 **독점**하는 것을 방지 가능 
    * **오버헤드**에도 불구하고 `대화식 시스템` OR `시분할 시스템`에 적합한 방식 
* 단점
    * CPU 선점에 따른 `문맥교환의 오버헤드`를 감수해야함 

* **`우선 순위`**
    * `내부적`으로 기준이 되는 **우선순위(Implicit Priority)**: 별도로 부여된 우선순위. 예를 들어 FCFS는 도착 순서, SPN은 크기가 기준이 됨 
    * **`우선순위 스케줄링`**: 여러 가지를 고려하여 계산된 값을 프로세스가 `생성`될 때 부여 (`PCB`에 우선순위 기록해둠), 이 값을 기준으로 스케줄링을 하는 방식, 대부분 **`선점 방식`** 
        * 프로세스가 생성될 때 부여된 우선순위가 완료 떄까지 변하지 않는 값이 되도록 하면 `정적(Static) 우선순위` 
        * 시스템에 있는 동안 조정되도록 하면 `동적(Dynamic) 우선순위`
        * 실행을 빨리할 목적으로 **비용**을 지불하고 우선순위를 높이도록 할 수 있음 -> `구매(Purchased) 우선순위` 
### 다단계 큐 (Multi-level Queue) 스케줄링
* `정적 우선순위`를 사용하는 스케줄링을 구현할 떄 적합한 자료구조 
* `같은 우선순위`를 가지는 프로세스들을 위해 필요한 큐 + `서로 다른 우선순위`의 프로세스들을 구별하고 관리하기 위한 큐 => **우선순위 개수만큼 큐가 필요됨** 
    * 프로세스들은 자신의 **우선순위 값**에 해당하는 `큐`에 들어감
    * 우선순위가 낮은 **하위 단계 큐**의 작업은 실행 중이더라도 **상위 단계 큐**에 프로세스가 도착하면 CPU를 뻇기는 `선점 방식` 
* `정적 우선순위` 이므로 큐들 간에 `프로세스 이동`은 **불가능**함  
### 다단계 피드백 큐 (Multi-level Feedback Queue, MFQ) 스케줄링
* 프로세스들의 `CPU 요구량`은 몰라도 `짧은` 프로세스들에게 유리하면서 `입출력 프로세스`를 우대할 수 있는 스케줄링 기법 
    * 완료까지 남은 시간은 몰라도 **지금까지 실행된 시간**을 잘 활용 -> `짧은 프로세스`에게 유리하도록 해줄 수 있음 (`SPN`, `SRT`와 비슷한 효과)
    * `입출력 프로세스`를 우대함으로써 CPU를 포함한 전체 자원들의 `활용도` 높임    
        * **짧은 연산** 후 **입출력**을 발생 -> CPU는 다른 프로세스에게 주어지고 **입출력 작업**과 **CPU 작업**이 **병행**하여 진행됨
* `동적 우선순위`를 기반으로 하는 `선점 방식`으로 운영됨 
* 우선순위 개수만큼 여러 단계의 `큐`가 있음 
    * 각 단계마다 **서로 다른** **CPU 시간 할당량**을 가지도록 함 -> **우선순위가 높은 단계**의 큐일수록 **적은** 시간 할당량
* 새로운 프로세스는 **최상위 단계**의 큐에 들어간 후 **FCFS**의 순서로 CPU를 할당받아 실행 -> 그 큐의 시간 할당량이 끝나면 **한 단계 아래**의 준비 큐에 들어감 -> .. -> 마지막 단계에서는 더 내려갈 단계가 없으므로 **라운드 로빈 방식**으로 실행됨 
* 어느 단계든 시간 할당량이 끝나기 전에 **입출력(OR 사건 대기)**로 CPU를 내놓게 되면 다시 **준비 상태**가 되었을 때 **한 단계 위**의 큐에 들어가도록 함으로써 **우선순위를 높여줌** 
* **높은** 레벨에 있을 수록 **I/O bound**일 것이다
* **작고**, **I/O bound**일수록 CPU를 더 받을 수 있다 (**선호**된다)
* **중간 단계의 맨 앞**에 있는 프로세스는 **상위 단계의 큐**들이 비어있는 경우에만 CPU 받을 수 있음 
    * 할당된 CPU는 `시간 종료 인터럽트`에 의해 `선점`되어짐
    * `입출력`이 발생하지 않는 한 그 **큐의 시간 할당량**까지 쓸 수 있음 
    * 즉, `중간 단계`의 큐에서 일단 CPU를 받은 프로세스는 실행 중 `상위 단계`의 프로세스에 의해 선점되지 않고 부여받은 `시간 할당량`까지는 보장된다 
* 장점
    * 상대적으로 **짧은 프로세스**들이 `하위 큐`까지 내려가지 않도록함 -> 비교적 `높은 우선순위`를 유지할 수 있도록 해줌
    * 입출력은 우선순위의 `상향 조정`을 함 -> **`입출력 위주의 프로세스`**가 선호됨 
    * 즉, `프로세스의 성격(Behavior)`에 맞도록 `우선순위를 조정`해줌으로써 `적응성(Adaptive)있는 스케줄링`이 가능한 것 
* MFQ의 변형
    * 각 단계에서 **시간 할당량**을 다 쓸 경우 그 단계의 큐에서 몇번의 **순환** 후 다음 단계로 떨어뜨리는 방법 -> *떨어뜨림을 완화함*
    * **입출력**의 완료시 단계의 **상승 폭**을 더 **크게** 줌 
    * **Aging 기법**을 활용하여 현재 큐에서 **대기**한 시간이 **일정 시간**을 넘기면 **상위 큐**로 이동시켜줌 
        * 여전히 존재하는 **무한 대기 현상**의 가능성을 방지 
### Fair-Share 스케줄링
* 지금까지 본 기법의 스케줄링들은 스케줄링의 대상이 되는 **모든** 프로세스들을 **하나의 그룹**으로 취급한것 
    * 즉 특정 프로세스에게 과도한 CPU 시간을 사용하도록 하면 나머지 프로세스들 모두가 그만큼 줄어든 CPU시간을 나눠야하는 불이익 감수 
* 프로세스들의 **특성**, **중요도**에 따라 그룹들을 나누고 -> 각각의 그룹에 **서로 다르게** 할애된 일정량의 CPU 시간은 각각의 그룹에만 영향을 미치도록 한다 
* 책에 예시 참고.. 
* (*스케줄링 기법*을 뭘 사용하든) 그룹별로 일정량의 **CPU 시간**을 할애 시, 특정 그룹에 속한 프로세스의 과도한 CPU 사용은 그 **그룹 내의 다른 프로세스들**에게만 불이익을 줄 뿐, **다른 그룹**로까지 파급되지 않도록 함 

## 실시간(Relatime) 스케줄링 
* `실시간(Realtime)` 시스템: 실행될 모든 프로세스들이 정해진 시간 내에 완료되어야하는 시스템 
    * `경성` 실시간(`Hard` Realtime) 시스템: 마감시한 내에 완료되지 않으면 *시스템이 중지*되는 등의 **치명적인 결과**를 초래 
        * -> 마감시간을 넘긴 후 완료되는 일은 아무 **가치x** 
        * 일반적으로 실시간이라는 것은 **경성**을 일컬음 
    * `연성` 실시간(`Soft` Relatime) 시스템 : 마감시한 내에 완료되지 않으면 *데이터의 손실* 등 피해가 발생하지만 시스템은 계속해서 운영 **가능** 
        * -> 마감시간을 넘긴 후 완료되는 일은 가치가 *점점 떨어지게 됨* 
    * `동적` 방법: 프로세스의 생성 시간이나 특성을 알 수 **없는** 경우에 사용됨
    * `정적` 방법: 프로세스들의 **특징**, **개수**를 알 수 있는 경우에 유욯함 
    * **실시간**으로 운영되는 환경은 대부분 **특수**하므로 실행되어야할 일들의 **성격**(**크기**, **발생주기** 등)이나 **개수**를 사전에 알 수 있는 경우가 많음 
### RM(Rate Monotonic) 알고리즘
* 대표적인 `정적 스케줄링` 방식 : **크기, 개수가 알려진** 프로세스들이 각자 **주기적**으로 발생되는 환경에서 사용됨 
* 프로세스들은 서로 **독립적**, 각자 **주기적**으로 발생되는 환경 + 각 프로세스의 **마감시한** == 각자의 **주기** + 주기가 짧을수록 **높은** 우선순위 
* 낮은 우선순위의 프로세스가 더 높은 우선순위의 프로세스가 도착할 경우 CPU를 뺏기게 됨 -> `선점방식` 
* `정적 환경`에서 최적의 기법 
* 장점: 스케줄링 **비용**이 적게 듦
* 단점: **새로운 프로세스**가 추가되는 환경에 적응하지 못하고 이 프로세스를 추가하여 **전체 스케줄링**을 다시 해야함 
### EDF(Earlist Deadline First) 알고리즘
* 프로세스의 `마감시한`이 가까울수록 `우선순위`를 높게 부여하는 `선점 방식`의 **`동적 스케줄링`**  
    * `동적`: **새로운** 프로세스가 도착했을 때 바로 대응이 가능 
    * `선점`방식: **우선순위**에 의해 CPU를 뺏길 수 있음 
    * 한 프로세스의 실행이 **완료**될 경우에는 **마감시한**이 제일 **가까운(임박한)** 것을 찾아 스케줄함 
* 모든 프로세스가 주기적일 필요 **X** 
    * 주기가 **있을** 경우: 마감시한 **==** 주기
    * 주기가 **없을** 경우: 마감시한이 **알려져 있어야함** 
* **RM**으로 할 수 있는 것은 **EDF** 가능 , **EDF**로 가능한것은 **RM**으로 가능할 수도 있고, 아닐 수도 있음 
    * RM은 **주기=마감시한** 이지만, EDF는 **주기!=마감시한**일 수 있기 때문이다 
* 장점: 새로운 프로세스의 **동적인 수용**이 가능
* 단점: 새로운 프로세스가 들어올때마다 가능한 스케줄을 찾기 위한 **계산 부담** 
* RM, EDF 모두 프로세스가 **상호 독립적**이라는 가정을 하고 있음 
    * **공유(Shared) 데이터**를 통한 프로세스 간 **통신**이 있을 경우 (**협력(Cooperative) 프로세스 관계**) 적용 X => **PIP**, **PCP** 기법이 사용되어야..

## 윈도에서의 스케줄링 
* `스레드 단위`로 `CPU`를 할당하는 `우선순위`에 의한 `선점` 스케줄링 방식
* **`실시간 클래스`** 
    * 우선순위 16~31 부여 -> 16개의 **큐** -> **정적 우선순위**로 운영됨 (우선순위 **변동X**) -> **`다단계 큐 (Multi level queue)`**
    * **다단계 큐** 각각은 **라운드 로빈 방식**으로 스케줄링됨 
    * 현재 실행 중인 스레드가 우선순위가 높은 스레드가 준비 상태가 되면 CPU가 **선점**됨 
* **`일반 클래스`**
    * 우선순위 0~15 부여 -> 16개의 **큐** -> **동적 우선순위**로 운영됨 (우선순위 **변동 O**) -> **MFQ**
    * 스레드는 초기에 부여받은 우선순위가 스레드의 실행 동안 *변할 수 있음* -> 스레드의 **기저 우선순위**의 **하한**보다 낮아지지 않고, 15보다 커지지 않음 
        * 스레드의 **최초 우선순위**는 *자신의 기저 우선순위*와 자신이 속하고 있는 *프로세스의 기저 우선순위*에 의해 결정됨 
    * 우선순위의 변동: **시간 종료 인터럽트**의 경우 **하향**, **입출력 완료**의 경우 **상향** => **입출력 위주 프로세스**가 우대받는 결과 (사용자에게 **빠른 응답**으로 만족감을 줌)