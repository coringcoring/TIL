# CHAP 04

## 스케줄링?
* **``스케줄링(Scheduling)``**: 일반적으로 여러 `프로세스`들이 번갈아 사용해야 하는 자원이 있을 경우, 주어진 시점에서 어떤 프로세스가 이 자원을 사용할 수 있도록 해 줄 것인가를 결정하는 것 
    * 그 자원이 CPU일 경우 -> `"CPU 스케줄링"` = **(CPU) 스케줄링** 
* 스케줄링의 프로그램도 `커널`에 포함됨 

## 스케줄링의 단계
* `수행 단계`에 따라.. 
1. **`장기 스케줄링(Long-term)`** (=`작업 스케줄링(Job Scheduling)`)
* 어느 작업을 `커널`에 등록시켜 `프로세스`를 만들어 줄 것인가를 결정 
* `일괄처리 시스템`의 경우: 새로 작업이 들어오면 먼저 `디스크`에 놓아둔 채 `일괄처리 큐`에서 대기하도록 한 후 `장기 스케줄러`를 거쳐 `프로세스`가 되도록 함
* `시분할`의 경우: `사용자의 접속 시도`를 허용할지 말지를 결정하는 단계라고 볼 수 있음 
* 즉, 이 단계는 요청된 일을 `프로세스`로 만들어 시스템에 알려진 일거리로 추가하느냐를 결정하는 것 -> **`다중 프로그래밍의 정도(Multiprogramming degree)`**를 조절하는 역할 
* 수행 횟수가 **적음**
* 대부분 `FIFO 방식` 사용 
* 좀 더 복잡한 스케줄링 방식 동원하는 경우 -> **계산 위주의 프로세스**와 **입출력 위주의 프로세스** 수를 적절히 맞추기 위해 프로세스의 **성격**을 반영하는 **우선순위 방식** 사용 가능 
2. **`중기 스케줄링(Medium-term)`**
* `보류 상태`의 프로세스들 중 어느 프로세스에게 `메모리`를 할당해줄 것인가를 결정 
    * `스왑아웃`된 프로세스들 중 어떤 프로세스를 다시 `스왑인`(or `Resume`)할 것인가를 결정 
3. **`단기 스케줄링(Short-term)`**
* `준비 상태`에 있는 프로세스들 중에서 어느 프로세스에게 `CPU`를 할당할지를 결정 
    * `프로세스 스케줄러` OR `디스패처(Dispatcher)`에 의해 수행됨
* 일반적으로 부르는 프로세스 스케줄링이 대부분 단기 스케줄링을 뜻함 
* **입출력**, **시간 종료 인터럽트**, **시스템 콜** 등과 같은 다양한 이유에 의해 가동됨
    * 횟수가 **잦음** -> 한 번 실행에 드는 시간을 **줄이는** 것이 중요 

## 스케줄링의 목적과 기준
* 어떤 것들이 시스템의 성능을 평가하는 잣대가 될 것인가?
1. **`응답시간(Response Time)`** -> `사용자`의 관점에서..
* `응답시간`?: 프로세스의 요청에 대해 시스템이 *최초로* **출력**을 내주기 시작할 때까지 걸린 시간. 
    * 사용자의 입장에서 가장 직접적으로 시스템의 성능을 느낄 수 있는 지표 
* `일괄처리`의 경우: `요청`으로부터 `결과`를 돌려받는 데까지 걸린 시간 -> `반환 시간(Turn-around Time)`이 지표가 됨 
    * 요청한 일이 얼마 후 쯤에는 완료될 수 있을 것이라는 `예측가능성 (Predictability)` 등도 지표로 활용될 수 있음 
2. `처리량(Throughput)`, `활용도(Utilization)` ->`시스템`의 관점에서..
* `처리량`?: `단위 시간`에 완료되어진 `프로세스`의 개수 
* `활용도`?: 주어진 시간 동안 특정 `자원`이 실제로 `가동`된 시간의 비율 
3. `공평성(Fairness)`: 가능한 한 `CPU 사용 시간`을 공평하게 나누어주어야 하는 것 
    * 특정 프로세스가 `장기간` CPU를 받지 못하게 되는 경우 피함
    * 시스템에 있는 여러 `자원`들은 가급적 `균형 있게` 사용되도록 해야함 
* `대화형 시스템`에서는 `응답시간`이 가장 중요한 지표/`일괄처리 시스템`에서는 `처리량`이 가장 중요한 지표 
    * `처리량`을 높이기 위해 `응답 시간`이 길어질 수도 있음 -> 지표들이 **상충**됨 -> 시스템을 사용하는 **환경**, **목적**에 맞는 지표를 치중해서 스케줄링을 해주어야함 
        * 어떤 경우에 지표들이 상충?
            * 프로세스들에게 **빠른 응답 시간**을 주기 위해 **CPU 스위칭**(**스케줄링**)을 자주 할 때 -> 그때마다 **문맥 교환**이 필요-> CPU 시간의 상당 부분이 **문맥교환**에 사용됨 => **사용자 프로세스**를 실행해 줄 시간이 줄어들어 전체적으로 **처리량**이 **감소** 
            * 주어진 기간 동안에 많은 프로세스를 처리하여 **처리량**을 높이려고 **수행시간**이** 짧은** 프로세스들을 주로 처리 -> 수행 시간이 **긴** 프로세스는 처리가 늦어져 **응답시간**이 **길어짐**
* 스케줄링을 만들 때 고려해야할 기준 
    1. 스케줄링의 대상이 되는 `프로세스`의 `성격` 
        1. `연산 위주(CPU bound 또는 Computation-bound)` 프로세스 : CPU를 사용하는 `연산`이 `입출력`에 비해 상대적으로 많을 때 
        2. `입출력 위주(I/O-bound)` 프로세스 : 그 반대의 경우
        * 목적에 따라 어떤 종류의 프로세스를 더 우대할 지를 생각해야. 
    2. 시스템이 사용될 `환경`에 따라 `응답시간`을 우선으로 할지, `처리량`을 우선으로 할지    
        * 특정 프로세스에게 우선적으로 빠른 응답 시간을 보장해야하는 경우가 있다면 이를 가능케하는 `기능`이 있어야함 
        * 프로세스의 크고 작음(`크기`=`완료` 때까지 요구되는 `CPU 실행 시간`)에 따라 어떤 것을 더 우선적으로 처리해야할지의 `기준` 가지고 있어야함

## 스케줄링 기법들 
* 스케줄링이 가동되어야하는 시기
    1. 프로세스가 `실행 상태`-> `대기 상태` (EX. `입출력 요청`) -> `비선점 방식` 
    2. 프로세스가 `실행 상태`-> `준비 상태` (EX. `시간종료와 같은 인터럽트` 발생) -> `선점 방식` 
    3. 프로세스가 `대기 상태`-> `준비 상태` (EX.`입출력 종료`) -> `선점 방식`
    4. 프로세스가 수행을 마치고 `종료`될 때 -> `비선점 방식`
* 구분
    1. **`비선점(Nonpreemptive)방식`**: 한 프로세스가 `CPU`를 할당받았을 때 `CPU`를 스스로 반납할 때까지 `계속 사용`하도록 허용하는 방법
    2. **`선점(Preemptive)방식`**: `CPU`를 할당받아 실행 중인 프로세스로부터 `CPU`를 `선점`(빼앗는다)하여 다른 프로세스에 할당할 수 있는 방식, 실행되는 프로세스의 의지와 상관없이 `CPU`를 뺏길 수 있음  
        * EX> 현재 CPU를 할당받아 실행 중인 프로세스보다 우선순위가 높은 프로세스가 도착하면 현재 프로세스의 실행을 중단하고 우선순위가 높은 프로세스에게 CPU를 할당하는 방법 
### FCFS(First Come First Service) 스케줄링 
* = `FIFO(First in First out)`
* `준비 큐`에 먼저 도착한 `프로세스`에게 먼저 `CPU`를 할당해 주며, `CPU`를 할당받은 프로세스는 스스로 `CPU`를 반납할 떄까지 `CPU`를 독점하여 사용하는 **비선점 방식** 
* 가장 `단순`한 형태로서 실제 시스템에서 바로 사용되기는 힘들지만 다른 스케줄링 기법의 `보조 장치`로서 활용 가능 (`우선순위`가 `동일`할 경우의 차선책)
* 단점
    * 프로세스가 CPU를 `독점`하여 사용하기 때문에 아주 `긴` 프로세스가 실행될 경우 오래 기다려야하므로 `대화식 시스템`에 적합하지 않음
        * **평균 응답 시간**이 길어지는 단점
* 장점
    * **준비 상태 프로세스**들의 개수, 크기 짐작 가능하다면 각각의 프로세스들이 언제쯤 실행될 수 있을지를 **예측 가능** 
    * **도착 순서**만이 실행 순서를 결정짓는다는 점에서 **공평함**
* 나머지 부분 책 참고 
### SPN(Shortest Process Next) 스케줄링 
* = `SJF(Shortest Job First)` 스케줄링 
* `준비 큐`(`큐`만으로 안됨. `위치`를 변경시켜주어야하므로 다른 data structure 사용해야)에서 기다리고 있는 프로세스 중에서 `CPU 요구량`이 가작 적은 것을 먼저 실행시켜 주는 **비선점 방식**
* 장점
    * 평균 응답 시간 **최소화** 가능
    * 실행해주어야 할 **프로세스** 수가 **충분**하다고 하면, `처리량`에 관한 한 매우 훌륭한 성능을 보임 
    * **FCFS**에 비해 빠른 응답 시간 기대 가능   
* 단점
    * **`무한 대기 현상`** 발생 가능 : 실행 시간이 긴 프로세스가 **CPU**를 할당받지 못하고 계속해서 대기하는 현상 
        * 무한대기 가능성을 낮추는 방법-> **`에이징(Aging)`**: 기다린 시간만큼 `우선순위`를 높이는 것 
    * **긴 프로세스**일수록 **편차**가 커져 `예측가능성`은 오히려 떨어질 것
    * 각 프로세스들의 `크기` (실행 시간의 길고 짧음)를 실행 전에는 정확히 알 수 없음에도 불구하고 그 `크기`를 가지고 **스케줄**을 해야함 
        * 해결 방법: **`지수 평균 방법 (Exponential Averaging)`**[`프로세스의 크기`를 **실행 전**에 **추정**해보는 것]-> 비슷한 **환경**에서 **반복적**으로 실행되어지는 프로세스들에 대해서는 적용할만 함 (이전의 **실행**되었을 때의 크기와 그때의 **추정** 크기로 **지금** 실행되어질 크기를 짐작) 
### SRT(Shortest Remaining Time) 스케줄링
* **SPN**을 `선점 방식`으로 운영 
* **준비 큐**에서 완료까지 남은 **CPU 요구량**이 가장 짧은 것을 **먼저** 실행시켜주는 방식. 
* 실행 도중 남은 실행 시간이 더 적은 프로세스가 준비 큐에 들어올 경우 현재 실행 중인 것을 **중단**하고 새 프로세스에게 **CPU**를 할당하는 **`선점 방식`** 
* 새로 도착하는 프로세스의 실행 시간 크기는 완료까지 남은 시간과 **같음** 
* CPU를 할당받아 실행한 만큼 **완료**까지 **남은 시간**(`remaining time`)은 줄어들 것 
* 단점: **SPN 방식**의 단점과 함께 완료까지 남은 실행 시간의 **계산**, 실행 시간이 짧은 프로세스가 **자주** 도착할 경우의 **잦은 선점**으로 인한 **문맥 교환**의 부담 
* **반환 시간**을 놓고 따져보면 **SRT**가 **SPN**보다 우수 
* SPN보다 **평균 완료(응답) 시간**이 짧아서 더 좋은 것으로 보일 수도 있으나, SRT는 남은 시간의 계산과 함께 SPN보다 더 많은 **문맥교환**이 요구되어 실제로는 **평균 응답 시간**이 좀 더 길어질 수 있음 
    * SPN을 수정하여 **평균 완료(응답) 시간**을 줄이는 방법: **`Future knowledge 스케줄링`** 
        * 가까운 미래에 도착하게 될 프로세스의 정보를 알 수 있다면? 
        * 1초만 기다리면 5와 2의 크기를 가진 프로세스가 도착한다는 것을 알 수 있다면 처음에 P1으로 CPU를 할당하는 대신 1초 동안 기다렸다가 **SPN**을 적용함 -> 처음 1초동안 **CPU를 쉬게 하여** 더 우수한 결과를 얻어낼 수 있음 
    *** SRT 스케줄링**을 위한 **`임계값(Threshold Value)`**를 정하여 프로세스의 남은 시간 차이가 **임계 값**을 넘지 않을 경우 선점되지 않도록 함 
        * 조금만 있으면 완료될 프로세스가 cpu를 받아 실행 중인데 더 짧은 프로세스가 준비 큐에 들어왔을 때 
        * 남은 시간이 꽤 긴 프로세스가 cpu를 받아 실행 중인데 새로 들어온 프로세스가 남은 시간이 더 짧지만 그래도 꽤 긴 프로세스가 들어왔을 때 
        * -> 임계값보다 작으면 **문맥교환**을 하지 않고 **그대로 실행**
        * -> 임계값보다 크면 **문맥교환**을 함 
