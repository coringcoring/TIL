# CHAP 08

* 운영체제는 주어진 메모리 크기 아래서 프로그램을 작은 조각으로 나누어 그 중에 일부분만을 메모리에 적재하되, 적재가 가능한 곳으로 흩어 (비연속적) 넣어줌으로써 사용자는 메모리에 대한 고민으로부터 벗어날 수 있게 됨 
* 프로그램의 일부분만이 적재되기 때문에 보다 많은 사용자 수용 가능 -> 모든 사용자가 메모리의 크기로부터 자유로워짐 
* `가상 메모리(Virtual Memory)`: 사실은 제한적인 크기지만 엄청나게 큰 메모리가 있는 것처럼 여겨지기 때문에 가상 메모리라 부름 

## 가상 메모리(Virtual Memory)를 위해서 
* `페이지`: 모든 프로그램들은 작은 조각으로 나눠지는데, 조각들의 크기가 모두 같다면 페이지
* `세그먼트(segment)`: 조각들의 크기가 서로 다르면 세그먼트 
* 블록(Block): 페이지 or 세그먼트는 메모리와 디스크 사이에서 한 번에 전송되는 전송 단위가 됨 
* 페이징: 가상 메모리의 관리에서 페이지로 나누었을 경우
* 세그먼테이션 시스템: 가상 메모리의 관리에서 세그먼트로 나누었을 경우 
* 주소의 사상(Mapping)
    * 가상 메모리의 관리를 위해 제일 먼저 해결되어야 할 부분 
    * `사상(Mapping)`: 실행 중인 프로그램에서 참조하는(Referenced)[발생되는(Generated),생성되는(Created)] 주소가 실제 메모리에 있는 주소와 달라서, 메모리상의 주소로 변환이 필요할 때 하는 것 
        * 가상 주소(Virtual Address): 프로그램에서 참조하는 주소
        * 실주소(Real Address): 실제 메모리상의 주소 
    * 고정분할과 절대 로더 : 주소의 사상이 필요 없는 경우 
        * 주소의 지정이 컴파일 시에 이루어짐 -> 프로그램이 실행될 때 참조하는 주소가 컴파일될 때 지정됨 
            * 참조하는 주소가 `실주소` -> 프로그램은 항상 메모리의 지정된 곳으로만 적재되어야 함 
        * 컴파일이 되고 나면 프로그램 내의 모든 명령어나 변수, 데이터 등의 주소가 메모리가 적재되어질 때의 메모리 주소로 지정되는 것이므로 -> *주소의 사상이 필요 없음* 
        * 장점: 단순하다
        * 단점: 두 주소가 같으므로 적재 시의 융통성이 배제됨 
    * 재배치의 경우 : 주소의 사상이 필요한 경우
        * 메모리에서의 위치를 적재될 때마다 바꿀 수 있음
        * 컴파일 시의 주소: 
            * 프로그램의 첫번째 줄을 0으로 함 
            * 나머지들 전부는 첫번째 줄로부터 얼만큼의 위치(또는 거리)에 있는지의(위치 값(Offset, Distance)) 값으로 지정
        * 실행 시간에 참조되는 주소는 프로그램 내에서 어느 정도의 위치에 있는지를 나타내는 상대주소(Relative Address)일 것임. 
        * 실주소 = 메모리에 적재될 때의 시작주소(Start Address) 값 (재배치 레지스터가 가지고 있음) + 상대주소 값   
            * 재배치 레지스터 값 + 상대주소  
        * 장점
            * 융통성 
            * 메모리의 효율적인 이용 
        * 단점
            * 프로그램 전부가 통째로, 연속적으로 메모리에 적재되어야 한다는 전제를 가짐 
                * 프로그램이 조각나고 이 조각들의 메모리 적재가 연속적이지 않다면 쓸모가 없게 됨 
* 가상 메모리로 관리될 떄 프로그램들은 디스크에 조각 난 모양으로 저장(반드시 차례대로, 연속적으로 저장될 필요는 없음)됨 
    * 이 중 몇개가 메모리에 비연속적으로 다른 프로그램의 조각들과 섞여 적재되는 것 
    * 메모리에 적재되어 있는 프로그램들이 다중 프로그래밍 정도에 포함되는 것들 
* 가상주소 (실행 중인 프로그램에서 참조하는 주소)는 참조하고자 하는 명령어나 변수 등이 자신의 프로그램에서 몇 번째 조각에 있으며, 그 조각 내에서 어느 위치(offset)에 있는지를 알려줌. 
    * 예시는 책, 그림 참고 

## 페이징 (Paging)
* 크기가 큰 프로세스는 많은 수의 페이지로, 작은 크기의 프로세스는 적은 수의 페이지로 
* 메모리는 프레임(Frame)이라 불리는 (페이지와 같은 크기) 것들로 나누어져 있고 일련 번호가 매겨져 있음 
    * 페이지의 크기: KByte (주소체계 생각해볼 때 2의 승수 배로 잡는 것이 상식적)
    * 프로세스의 실행이 진행되는 과정에 따라 디스크와 메모리를 오가며 교체되는 단위, 사상의 단위 : 페이지 
        * 한 프로세스의 전체 페이지들은 디스크에 저장됨 
        * 이 중 몇개가 메모리에 비연속적으로 다른 프로세스들의 페이지들과 섞여 적재됨
* 페이지 사상 테이블 (Map Table)
    * 운영체제가 가상주소를 실주소로 변환하기 위해 프로세스당 하나의 페이지 테이블을 만들어 둔 것 
    * 테이블의 크기는 해당 프로세스의 페이지 개수와 비례 
    * `사상을 위한 정보`는 `페이지` 당 하나씩 있어야함 
    * `k개의 페이지`를 가지는 프로세스의 페이지 테이블은 `k개의 엔트리`로 구성되고 엔트리 하나의 크기는 보통 `4byte`로 잡음 
    * 한 프로세스에서 나뉘는 페이지들은 일련번호를 가짐 -> 페이지 테이블은 이 번호 순서대로 엔트리를 배치시킴 
        * ex. 테이블에서 첫 번째 엔트리는 프로세스의 첫 번째 페이지를 위한 사상 정보를 가지는 것. 
    * 엔트리 
        * 존재(Residence) 비트: 페이지가 메모리에 적재되어 있는가? (적재된 경우: 1, 아닌 경우:0)
            * 1의 경우: 적재되어 있는 프레임 번호 
            * 0의 경우: 이 페이지가 저장되어 있는 디스크의 주소를 나타내는 필드들이 있음 [demand fetch: 적재요구가 있을 때 디스크에서 정보를 끌고 오는 것]
* 실주소를 찾아내는 과정 
    * 가상주소 `<p,d>`
        * p: 페이지 번호 
        * d: 페이지 내에서의 위치 
    * 페이지 테이블은 메모리의 `커널 영역`에 보관됨 
    * 실행 중인 프로세스의 페이지 테이블 시작주소는 `페이지 테이블 기준 레지스터(Page Table Origin Register)`에 들어있음 
    * 기준 레지스터의 값에 p를 더해 [p의 엔트리 크기를 곱한 값을 더하는거임. 메모리는 워드 단위로 주소가 붙여지므로 워드의 크기나 엔트리의 크기를 같게 하는 경우는 p만 더해도 해당 엔트리를 찾게됨] 페이지 테이블에서 페이지 p의 사상 정보를 갖고 있는 엔트리를 찾은 후 `존재 비트`를 확인하게 됨 
        * 존재 비트가 1인 경우: p가 적재되어 있는 `프레임 번호` f를 알 수 있음 -> `프레임의 시작주소`= `프레임 번호 값` * `페이지 크기` -> `실주소`[프레임 내에서 접근해야할 워드의 주소] = `프레임의 시작주소` + `d` 
            * 페이지 테이블의 각 엔트리에 프레임의 시작주소 대신 프레임 번호를 넣은 이유 : **address에 소용되는 bit수를 줄여주기 위해서** -> 엔트리 크기가 줄어듦 -> 엔트리가 들어있는 페이지 테이블(멀티 프로그래밍 degree에 포함되는 것들)의 크기가 줄어듦 -> 필요한 메모리 양이 줄음 -> **메모리 save 가능** 
        * 존재 비트가 0인 경우: 접근하고자 하는 워드를 포함하는 페이지가 메모리에 없음 -> 실행을 계속하기 위해 `디스크의 주소`로부터 이 페이지를 메모리에 적재해야함 -> 그 후 엔트리의 존재 비트를 1로 바꿈 -> 적재된 프레임 번호를 기입한 후 사상 계속 진행 -> `실주소` 얻을 수 있음 
* 운영체제는 정확한 상황을 위해 `변동`이 있을 때마다 `페이지 테이블`을 갱신, 관리하고 있어야함 
* 페이지들의 적재와 교체 등을 위해 메모리의 `빈 프레임`에 관한 정보 역시 유지, 관리해야함 
    * 페이지의 메모리 적재는 프레임과 크기가 같으므로 빈 프레임만 있다면 그 중에 아무거나 할당해주면 됨
* 프로세스와 페이지 테이블, 메모리에 관하여 
    * 각 프로세스의 PCB에는 자신의 페이지 테이블 주소가 있음 -> CPU가 스위칭될 때 이 값 역시 기준 레지스터에서 바뀜 
    * 프로세스의 개수를 생각하면 많은 수의 테이블들을 모두 메모리에 보관하기 어려움 -> 다중 프로그래밍 정도에 포함되는 프로세스들의 테이블들만 보관하고 나머지는 디스크(보류상태 프로세스들의 테이블)에 둠. 
    * 가상 주소의 사상을 위해 2번의 메모리 접근이 필요 
        1. 페이지 테이블의 접근
        2. 알아낸 실주소를 가지고 실제 워드의 접근 
        * 가상 주소를 사용하지 않는 방식에 비해 두번의 메모리 접근이 필요하여 프로그램의 실행 시간을 늦어지게 만듦 -> 이 시간을 최대한 줄이는 것이 가상 메모리의 장점을 살리는 지름길 => 기본적으로 사상이 요구될 가능성이 높은 테이블들은 디스크가 아니라 메모리에 두기 OR 더 빠른 사상을 위해 추가의 레지스터들을 사용해 페이지 테이블을 보관(테이블의 크기가 아주 작을 때나 가능하므로 도움이 되지 X) OR 연관(Associative) 메모리 사용 