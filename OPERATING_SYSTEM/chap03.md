# CHAP 03

## 프로세스란? 
* **`프로그램`** + **`데이터`**를 기본으로 정상적인 실행을 위해 필요한 환경을 시스템으로부터 부여받은 **능동적인** 존재 
* 시스템의 입장: 일거리 하나하나가 프로세스 
* **CPU를 할당받게 되는 단위**, **주어진 자원들의 소유자로서의 역할** 
### 프로세스 제어 블록 (Process Control Block, PCB)
* 테이블 모양의 자료구조. 프로세스에 대한 모든 것을 표현하는 PCB가 만들어진다 = 프로세스 하나가 만들어진다 
* *운영체제*가 프로세스를 관리한다 = 해당 PCB에 대한 다양한 행동 (만들고, 수정하고, 관련 리스트로 연결하고, 지우고..)
* 기본적으로 PCB는 **메모리**에 저장 
* PCB에 저장되는 정보들 (+a는 운영체제마다 다를 수 있음) 
    * 프로세스 번호
    * 프로세스의 상태
    * 프로세스 우선순위
    * 프로그램 카운터 값
    * 메모리 포인터
    * 문맥 데이터
    * 할당받은 자원들에 대한 목록 
    * 계정 정보
    * 입출력 정보 

### 프로세스의 상태 (Process State)와 변화
* `생성 상태(Created)`
    * 사용자가 요청한 작업이 **커널**에 등록되고 **PCB**가 만들어져 **프로세스**가 만들어진 다음 **보류 준비**나 **준비** 상태로 되기 위해 잠시 거치는 상태 
    * 운영체제는 **메모리**를 검사하여 충분한 공간이 있으면 **준비 상태**로 바꾸고, 그렇지 못한다면 **보류 준비 상태**로 만듦. 
    * **준비 상태**는 시스템에 따라(OS에 따라) 구현을 빼는 경우도 있음.
 * `준비 상태(Ready)`
    * `CPU`를 할당받기 위해 기다리고 있는 상태 -> `CPU`만 주어지면 바로 실행할 준비가 되어있는 상태 
    * **다중 프로그래밍**의 경우: 준비 상태의 여러 프로세스들은 **메모리**에 적재되어있으며 CPU를 할당받기를 기다리고 있음 -> **`큐 (또는 리스트 등)`**이 사용됨 
    * `CPU 스케줄링`?: 준비 상태의 프로세스들이 **순서**에 따라 CPU를 할당받으면 실행 상태가 되는데 이때 **순서**를 정하는 것 
* `실행 상태(Running)`
    * CPU를 할당받아 실행중인 상태 
    * **디스패치(Dispatch)**: CPU를 할당하는 것
    * **단일 CPU 시스템**: 단일 CPU에서는 오직 한 개의 **프로세스**만이 CPU를 사용할 수 있기 때문에 한 프로세스만이 실행 상태에 있을 수 있음 
    * 실행 상태의 프로세스는 **CPU 스캐줄링 정책**에 의해 CPU를 뺏길 수 있음 -> 이 경우 준비 상태로 변함
        * `시간 종료(Timeout)`: **시간 할당량(Time Quantum)**이 소진되어 뺏길 때, **인터럽트**가 동원되어 처리됨
        * `입출력이 필요하게 되어 시스템 호출을 할 때`: *실행 상태의 프로세스*가 **입출력**이 필요하여 `시스템 호출`을 함-> 입출력 처리의 종료를 기다리면서 **대기 상태**로 바뀌게 됨 -> CPU는 바로 준비 상태의 프로세스들 중에서 하나를 선택해 실행해줌. 
* `대기 상태(Blocked)`
    * 프로세스가 실행되다가 `사건이 발생`했을 때 CPU를 양도하고 요청한 일이 완료되기를 기다리면서 대기하는 상태 
        * `사건 발생`: **입출력 처리** 요청, 바로 확보될 수 없는 **자원**을 요청 
    * 대기 상태의 프로세스 관리를 위해 **큐(또는 리스트)**가 사용됨 
    * 요청한 일이 완료되면 다시 실행 차례를 기다리기 위해 **준비 상태**로 바뀌면서 **준비 큐**에 들어감 
* `종료 상태(Terminated)`
    * 프로세스가 종료될 때 아주 잠시 거치는 상태. 
    * 할당되었던 모든 **자원**들이 회수되고 **PCB**만 **커널**에 남아있는 상태 
    * 운영체제가 시스템에 남겨져 있는 이 프로세스의 흔적들을 최종 정리 후 **PCB**를 삭제하면 프로세스가 완전히 사라지게 됨 
* `활성 상태(Active State)`
    * `준비`, `실행`, `대기` 상태들 
    * 실행될 프로그램과 데이터 등을 위해 **메모리** 공간의 일정량을 부여받았음을 의미 -> **다중 프로그래밍**(의 개수 또는 정도; **디그리(degree)**)에 포함되는 프로세스들 
    * **보류(Suspension)**?: 메모리가 부족하거나 다른 이유에 의해 시스템은 활성 상태의 프로세스로부터 메모리를 회수하는 경우가 생기는 것
* `보류 상태(Suspended)`
    * 프로세스가 메모리 공간을 빼앗기고 디스크로 나가야하는 것 
    * 보류해야하는 상황 
        * 한정된 메모리 공간의 여유가 사라져 시스템이 당분간 메모리 회수해도 문제되지 않을 프로세스들을 골라 보류시켜 메모리 공간 확보 
        * 메모리 여유는 없는데 지금 생성된 프로세스가 더 중요한 것이라 반드시 메모리를 주어야하는 경우 
        * 입출력에 비해 턱없이 빠른 CPU 속도를 인정한다면, 메모리를 꽉 채우고 있는 프로세스들이 전부 **입출력** 중이라 **CPU**가 쉬고 있을 경우 -> 새로운 프로세스를 받아들여 CPU를 가동시키고 싶다면 먼저 **메모리**를 확보해야하고 입출력 때문에 **대기** 중인 프로세스들 중 누군가를 **보류**시켜야. 
    * **`스와핑(Swapping)`**
        * `스왑되어 나간다(Swapped out)`: 프로세스가 메모리 공간을 빼앗기고 디스크로 나가야하는 것 
        * `스왑되어 들어온다(Swapped in)`: 다시 메모리로 들어오는 것 
    1. `보류 준비 상태(Suspended Ready)` : **생성**된 프로세스가 바로 메모리를 받지 못할 때나, **준비** 또는 **실행** 상태에서 **메모리**를 잃게될 떄를 위해 필요 
        * **실행 상태**의 프로세스가 CPU를 반납하면서 **준비 상태**로 바뀔 떄 **메모리 공간**까지 잃어야하는 경우 -> 보류 준비 상태로 Suspended
        * 충분한 메모리 공간의 확보를 위해 **준비 상태**의 프로세스를 보류시킬 수 밖에 없는 경우 
        * **높은** 우선순위의 **보류 대기 상태** 프로세스가 **준비 상태**가 되면서 **실행 상태**의 프로세스로부터 CPU를 뻇기게 되는 경우 
        * **보류 준비 상태**의 프로세스는 *메모리의 여유가 생기거나*, *준비 상태의 프로세스가 전혀 없을 때* (**CPU**가 놀지 않게 하기 위해) **대기 상태**의 프로세스를 **보류 대기 상태**로 만들고 **메모리 공간**이 확보되면 **준비 상태**로 바뀌게 (`Resume`) 됨 -> `스와핑` 발생 
    2. `보류 대기 상태(Suspended Blocked)`
        * **대기 상태**일 때 메모리 공간을 잃은 상태 
        * **준비 상태**의 프로세스가 아예 없어 대기를 보류 대기 상태로 만드는 경우
        * **준비 상태**의 프로세스가 있어도 메모리 여유 공간 더 확보 위해 보류 대기 상태로 만드는 경우도 있음 
        * 특별한 경우가 아니면 **입출력**이나 기다리던 사건의 **종료** 시 `보류 준비 상태`가 됨 
    * 보류 대기 상태 -> `대기 상태` 되는 경우
        1. 실행 중인 프로세스가 종료되어 메모리에 여유가 생김
        2. 대기시켰던 원인이 곧 해소될 것이라 판단되는 프로세스가 `보류 대기`에 있는데 `보류 상태` 중인 어떤 프로세스보다 **우선순위**가 높다
        3. 이 프로세스에게 메모리를 주고 **대기 상태**로 만드는 것이 더 효과적 
            * 그냥 보류 준비 중인 프로세스를 준비 상태로 만들어준다면 얼마 지나지 않아 방금 말한 프로세스 때문에 또 한번의 **스와핑**을 겪어야함
    * 보류 상태의 필요
        * 메모리 공간 확보
        * 실행되는 프로세스의 현재 결과가 바라던 것이 아닌 오류가 보일 때 
        * 시스템에 위해를 가할 수 있는 수상한 행동을 보일 때
        * 주기적인 일이라서 다음 주기의 실행 때까지 메모리를 회수해도 문제되지 않을 때 등 
    * *활성 상태, 보류 상태에 있는 것들은 모두 **프로세스**! 모두 **PCB**를 가지고 있음! **보류상태**인 프로세스들도 최소한의 **PCB**는 **메모리**에 남겨둬야(상황에 따라 디스크,메모리 왔다갔다 함)*
    * 문맥 교환(Context Switching)
        * 프로세스의 상태 변화는 `인터럽트`에 의해 처리됨 
        * `인터럽트` 이전에 실행되던 프로세스가 `인터럽트`를 처리한 후에 계속 실행이 되기도 하지만, *다른 프로세스로 CPU가 할당될 수도 있음*
            * EX> 시간 종료, 우선순위, **입출력 발생** 
            * BUT 대부분, 실행 중 다른 프로세스의 **입출력 완료**를 알리기 위한 인터럽트가 도착한 경우, 인터럽트 처리 후 좀 전에 실행되던 프로세스를 그대로 계속 실행시켜줌 
        1. **`모드 스위칭(Mode Switching)`**
            * 인터럽트 처리 전후 일이 **같을** 때: 해줄 일이 적음
            * 인터럽트 처리를 하는 동안 *변경*될 가능성이 있는 최소한의 정보(**PCB**의 일부분)만 보관 
            * **사용자 모드**에서 인터럽트 처리를 위해 **커널 모드**로 바뀜 > 처리가 끝난 후 다시 **사용자 모드**로 바뀌면 됨 
            * 단순히 `모드 스위칭`이라고만 부름 
        2. **`프로세스 스위칭`** == **`문맥 교환`** 
             * 인터럽트 처리 전후 일이 **다를 때**
             * **문맥**의 저장, **PCB**에서 관련 **데이터**들의 변경, **PCB**를 적절한 상태의 **큐**에 옮김, 실행될 프로세스를 고름(**스케줄링**), 프로세스의 **PCB** 변경, **문맥**의 **복원** 
             * 해주어야 할 일이 더 요구되기 때문에 이를 `문맥교환`이라 함 
## 스레드(Thread)
* 스레드: **스케줄링**의 단위. 프로세스가 가지는 자원(*주소 공간* 등)을 공유하면서 각자는 자신의 **실행 환경**(**프로그램 카운터**로 표현되는 현재의 실행 위치와 **스택**, **레지스터** 값들)을 가지는 것. 
    * 프로세스는 **자원**의 소유자로서 존재 
* **`다중 스레딩(Multi-threading)`**: 하나의 프로세스를 다수의 스레드로 만들어 실행하는 것 
    * 자원의 생성과 관리과 `중복`되는 것을 줄일 수 있음 
    * 다중 스레딩에서 `프로세스`: **보호**와 **자원**의 할당 단위(프로세스의 코드,데이터를 수용하기 위한 가상 주소 공간과 CPU, 다른 프로세스의 파일들, 입출력에 사용되는 자원에 대한 보호된 액세스를 보장하기 위한 단위)
    * 다중 스레딩에서 `스레드`: 각각은 스레드의 **수행 상태**(실행, 준비), 실행상태가 아닐 경우를 위한 **스레드 문맥**, 각자의 **실행 스택**, 자신이 속한 프로세스가 가지는 메모리와 자원에 대한 **접근 권한**을 가짐 
    * 스레드 = **스레드 제어 블록+ 스택(사용자 스택+커널스택)**
    * **PCB**와 **사용자 주소 공간** 공유 => 스레드 자신이 속한 프로세스의 상태와 자원들 **공유** 
        * 한 스레드에 의해 메모리 데이터가 변경될 경우 다른 스레드들은 변경된 데이터를 사용하게 됨
        * 열린(OPEN) 파일은 다른 스레드들에게도 열린 상태로 사용됨 
* `스레드 제어 블록 (Thread Control Block)` : 실행 중의 **레지스터 값**, **우선순위**, **스레드**와 관련된 정보 등을 위해 필요한 자료구조. (프로세스의 `PCB`와 같은 개념!)
* 스레드의 장점 
    * 성능: 시간과 비용이 프로세스 단위로 이루어질 때 보다 **빠르고 저렴**
        * EX1. 파일 서버가 다양한 파일처리 요청에 대해 스레드를 만들어 냄
        * EX2. 논리적으로 다른 기능을 포함하고 있는 프로그램을 여러 개의 스레드로 구현하여 시간과 비용을 줄임
        * EX3. `프로세스 간의 통신(Inter Process Communication)` 할 때 **커널**의 개입을 필요로 하지만, 한 프로세스 내의 스레드 간 통신은 메모리와 파일을 공유하기 떄문에 커널의 개입이 필요없음 
* CPU의 할당 단위가 `스레드`라고 했으므로 `CPU 스위칭`을 위한 스레드 단위의 자료(**스레드 제어 블록**)는 유지되어야 하며, 여전히 `프로세스 단위`로 행해지는 **보류 종료** 등은 해당 프로세스에 속하는 *전체* 스레드에 동일한 영향을 미침. (메모리라는 자원은 **프로세스 단위**로 주어지는 것이므로)
### 스레드의 상태와 동기화(Synchronization)
* 스레드도 실행, 준비, 대기와 같은 **상태**를 가짐 
    * `보류`는 `프로세스` 레벨의 개념이므로 `스레드`에서는 필요 없는 상태임
    * `대기`는 **레지스터 값**, **프로그램 카운터**, **스택 포인터** 등의 보관이 요구됨 
    * 스레드의 **종료**는 해당 스레드의 **레지스터 값**들과 **스택**을 없애게 됨
* **스레드** 실행의 `동기화`
    * 한 프로세스 내의 스레드들은 그 프로세스의 `주소 공간`과 `자원`들을 공유함 -> 특정 스레드가 변경시킨 내용이 다른 스레드에 바로 영향을 미침
    * 따라서 `오류`를 야기할 수 있는 **상호** 간의 `간섭`이나 `데이터의 파괴` 등을 방지하기 위한 **스레드 실행의 동기화**가 요구됨 => 5장에서..
### 스레드의 종류 
1. **`사용자 레벨 스레드 (User Level Thread)`**
* `스레드 라이브러리`에 의해 관리됨
    * `스레드 라이브러리`: 스레드의 **생성**, **소멸**을 위한 코드 / 스레드 간의 메시지나 데이터의 **전달** / 스레드의 **스케줄링**/ **스레드 문맥**의 보관/ **재저장** 등을 담당함 
* 스레드와 관련된 모든 **행위(Activity)**는 `사용자 공간`에서 이루어지므로 *커널은 스레드의 존재를 알지 못함* -> 특정 프로세스에 속한 스레드들 각자가 일으키는 행위를 그 스레드가 속한 `프로세스`의 행위로 인식 
* 특정 스레드의 실행에서 `대기` -> 자신이 소속된 `프로세스`의 `대기`를 초래 
    * 당시 `실행` 중이었던 스레드는 지금은 실제로 실행 중이 아니지만, `스레드 라이브러리`에 의해 계속 `실행`으로 간주되고 있다가[실행 중이었다는 사실을 표시해둠] 나중에 `CPU`가 다시 이 프로세스에 할당되었을 때 계속 실행해나갈 수 있도록함 
* 스레드 실행 중 해당 프로세스가 `시간초과`가 될 경우
    * `커널`은 `프로세스의 스위칭`을 수행
    * 당시 실행 중이던 스레드는 `스레드 라이브러리`에 의해 `실행` 상태로 유지되다가 해당 `프로세스`가 `CPU`를 받으면 다시 실행됨 
    * (`스레드의 스위칭` 중 `프로세스 스위칭`이 일어나더라도 `CPU`를 다시 받았을 때 `스레드의 스위칭`이 계속 진행되도록 조치함)
* 장점
    * `스레드 스위칭`에 **커널의 개입**이 필요 없음 -> 유저에서 커널 모드, 커널에서 유저 모드로의 두 번의 **모드 스위칭**이 필요 없다 
    * 스레드 간의 스위칭 시 **운영체제가 정한 스케줄링**에 따를 필요가 없음 
        * 스레드 간의 스위칭은 **라이브러리**에 있는 `스위칭 프로그램`에 의해 이루어지므로
        * 응용 별로 **독자적인 스케줄링**을 사용할 수 있으며 어떤 운영체제에서도 운영이 **가능** 
* 단점
    * 특정 스레드의 `대기`가 자신이 소속된 프로세스 내의 모든 스레드들의 `대기`를 초래 
    * `CPU`가 `프로세스 단위`로 할당되기 때문에 `다중처리`의 환경이 주어진다고 해도 스레드 단위의 다중처리가 되지 **못함** 
        * 커널이 스레드를 보지 못하기 때문에 같은 프로세스에 속한 여러 스레드들이 *서로 다른* `CPU`를 할당받아 *동시에 실행될 수 없음* 
2. **`커널 레벨 스레드(Kernel Level Thread)`** 
* 모든 스레드의 관리를 `커널`이 하는 경우 
* `사용자 레벨 스레드`의 단점 극복 가능 
    * `스케줄링`은 `커널`에 의해 `스레드 단위`로 이루어지므로 
    * `다중처리`의 환경일 경우 한 프로세스 내의 다수 `스레드`는 각각 `처리기`를 할당받아 **병렬 실행**이 가능 => **스레드 단위의 다중처리가 가능** 
    * 한 스레드의 `대기` 시 `같은 프로세스`에 속한 다른 스레드로 `스위칭`이 가능 
        * but... 같은 프로세스에 속한 스레드 간의 스위칭에도 `커널의 개입`이 필요하므로(OS개입) `모드 스위칭`이 요구됨 
* 단점: 스레드 관리 파트가 추가되므로 os가 커지고 복잡해져서 `비용`이 생김 
* **`원격 프로시저 호출(Remote Procedure Call, RPC)`**
    * 커널 레벨 스레드에서 CPU가 하나 있는 `단일 처리기 환경`에서 두 번의 순차적인 호출 (다른 `서버`에 있는 `프로시저`를 호출, 또 다른 서버에 있는 프로시저를 순차적으로 호출)
    1. `프로세스`로 RPC를 호출하는 경우
        * 책 P48 그림 참고 -> 종료시간이 늦춰지고 있음
    2. 두 개의 `스레드`를 이용하여 RPC를 호출하는 경우 
        * 첫번째 호출을 한 스레드에게 맡기고 대기가 될 떄 바로 다른 스레드를 실행시켜 두번쨰 호출을 하게 함 
        * 두 개의 스레드가 대기 중인 시간대가 `중복`된 만큼 `전체 일의 종료 시간`이 앞당겨짐 
    * `단일 처리 시스템`의 경우에도 스레드를 만드는 것이 프로세스를 만드는 것보다 *시간,비용 면에서 이로움* + 응용에 따라 *전체 실행 시간도 단축시킬 수 있음* 
