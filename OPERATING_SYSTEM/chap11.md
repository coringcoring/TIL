# CHAP 11

* 파일 시스템은 대부분 디스크에 저장됨 -> 파일 시스템에 대한 접근 요청은 디스크 시스템에의 접근을 필요로 함 
* 컴퓨터 시스템에는 많은 프로세스들이 동시에 존재 가능 -> 이들의 실행 중 저마다의 파일 접근 요청 -> 요청은 커널의 파일 시스템을 통해서 디스크 시스템으로 전달 -> 디스크 시스템에 짧은 시간 동안에도 수많은 접근 요청들이 들어올 수 있음 
    * 디스크 시스템의 성능 향상 -> 결과적으로 컴퓨터 시스템 전체의 성능 향상을 위해 `디스크 접근 요청들에 대한 스케줄링` 필요됨 

## 디스크의 구조 
* 디스크 시스템: 디스크 팩[데이터를 저장] + 디스크 드라이브[저장/저장된 데이터를 읽어내는데 동원되는 구동 장치] 묶어서 표현한 것 
    * 디스크 팩: 전원이 끊겨도 데이터를 보존할 수 있는 저장장치 -> 여러 개의 원판 디스크로 이루어짐
        * 기계적인 움직임(Mechanical move) 2가지
            1. 회전 동작: 회전축에 의한
            2. 전후 동작: 붐(Boom)에 의한 
            => 이 2가지 동작이 연동되어 특정 위치에 헤드를 위치시키고 읽기/쓰기가 이루어짐 
        * 디스크의 한면 
            * 여러개의 트랙으로 이루어짐    
            * 트랙은 여러 개의 섹터로 이루어짐
                * 섹터단위로 데이터가 쓰이거나 읽힘 
                * 블록: 일반적으로 섹터의 크기 or 섹터 크기의 정수배 
            * 트랙 사이의 gap: 트랙을 구분하기 위함
            * 섹터 사이의 gap: 데이터의 정상적인 읽기, 쓰기를 위한 여유 공간 (디스크의 회전 속도를 일정 속도 이상 높이기 위하여)
            * 여러 개의 섹터 -> 여러 개의 트랙 -> 여러 면 -> 디스크 팩 
        * 암(Arm)의 길이는 같음 -> 헤드는 각 면의 같은 트랙에 위치 
        * 실린더(Cylinder): 디스크 팩에서 동심원에 있는 모든 트랙을 묶은 것 
            * 용량이 큰 데이터를 디스크 팩에 순차로 저장할 때 실린더 단위로 저장함
                * 이유: 헤드의 이동을 최소화하기 위해서 
        * 이동 헤드(Moving head) 디스크: 헤드가 하나씩 있는 시스템. 데이터가 있는 트랙을 옮겨다니면서 읽기,쓰기를 함
        * 고정 헤드(Fixed head) 디스크: 헤드가 트랙마다 존재 -> 헤드가 트랙을 따라 이동할 필요가 없음 -> 빠르다 but 가격 비쌈 
    * 디스크의 헤드는 빨리 회전하는 표면에서 미세하게 떨어져 데이터를 감지함 
        * 조금만 충격을 주어도 디스크 표면이 손상되어 오류 블록(Bad Block) 발생 가능 
    * 윈체스터 디스크(Winchester Disk): 헤드와 표면 사이의 불순물과 진동을 거의 없도록 만들어 헤드를 더 밀착시키고, 데이터를 더 촘촘하게 넣어 디스크의 용량을 증가시키는 기술 
        * 일정 간격에 회전속도가 빠르다면 그만큼 데이터를 느슨하게 넣어줘야함
        * 일정 간격이라면 헤드를 더 밀착시키면 데이터의 감지 능력이 뛰어나므로 데이터를 더 촘촘하게 넣을 수 있음
        * PC의 하드 디스크 
    * 일정 각속도(Constant Angular Velocity; CAV)
        * 하드 디스크는 회전 속도가 일정함 
        * 회전축에서 멀어지는 바깥쪽 섹터일수록 헤드 밑을 지나가는 속도가 빨라지게됨 -> 데이터를 느슨하게 넣어줘야함 => 용량을 떨어뜨리는 요소가 됨 
    * 일정 선형 속도(Constant Linear Velocity; CLV)
        * CD나 CD-ROM 
        * 중심에서 바깥쪽으로의 나선형 트랙을 만들고 각 섹터의 밀도를 똑같이 함
        * 바깥쪽 섹터일수록 데이터가 더 촘촘하게 들어가게 됨 -> 회전 속도를 더 천천히 하여 헤드가 감지할 수 있도록 함
        * 모든 섹터의 밀도를 같게 하여 용량을 올리되 회전 속도를 조절하는 방식 
    * 디스크 시스템에서의 특정 섹터 주소 지정 
        1. 실린더 번호(또는 트랙 번호)
        2. 표면 번호
            * 표면 번호가 실린더 번호보다 먼저 지정될 수도 있으나 대용량의 데이터를 순차적으로 저장할 때 실린더 단위로 하는 것이 유리하다는 점을 고려하면 실린더 번호가 먼저 지정되는 것이 일반적임
        3. 섹터 번호 
        * -> 이런 물리적 주소는 사용하기 복잡함 => 논리적인 상대 주소 사용하기도 함 
            * 디스크 시스템의 데이터 전체를 블록들의 나열(Sequence of Blocks)로 보고 각각의 블록에 번호를 부여 -> 임의의 블록에 접근할 수 있도록 함 
    * 디스크에서 특정 데이터, 특정 섹터에 접근하고 입출력이 이루어지는 과정 
        1. 탐색 시간(Seek Time): 주어진 주소로부터 실린더 번호를 보고 헤드를 해당 트랙에 이동시킴 
            * 디스크 접근시간에 가장 많은 비중, 이를 어떻게 처리하냐에 따라 성능이 달라짐 
        2. 회전 지연 시간(Rotational Delay 또는 Latency Time): 지정된 섹터가 회전하여 헤드 밑으로 오는데 걸리는 시간
            * 회전 속도에 달려있음 
        3. 전송 시간(Transfer 또는 Transmission Time): 섹터가 헤드 밑을 회전하는 동안 읽거나 쓰게되는 시간 
            * 회전 속도에 달려있음 
        * 디스크에서의 접근 시간 = 탐색 시간 + 회전 지연 시간 + 전송 시간 
        * 디스크 스케줄링: 트랙에 산재한 입출력 요청들에 대한 탐색을 어떤 순서로 처리할 것인가 
            * 고정 헤드 디스크 시스템은 디스크 스케줄링이 필요 없음 (각 트랙마다 헤드가 존재하기 때문에 탐색 시간이 필요 없음)
    * 디스크 스케줄링 기법의 평가 기준
        1. 단위시간당 처리량(Throughput): 같은 시간 동안 디스크의 입출력 요구를 보다 많이 처리할 수 있어야함 -> 최대화해야함
        2. 평균 응답 시간(Mean Response Time): 각 디스크 입출력 요구들에 대해 가능하면 빠른 시간 내에 서비스를 제공해주어야 함 -> 최소화해야함 
            * 평균 대기 시간(Mean Waiting Time)을 최소화해야함 
        3. 응답 시간의 예측성 (Predictability): 디스크 입출력 요구를 보낸 측에서 요청에 대한 자신들의 서비스가 언제 끝날 것인지 추측 가능한가와 관련된 지표 
            * 예측성을 판단하기 위한 요소 : 응답 시간들의 분산(Variance) 
                * 분산이 작을수록 예측성이 좋음
                * 분산이 크면 특정 요구에 대한 응답 시간이 어느 정도일지를 추측하기가 어려워짐
            * 분산을 줄이고 예측성을 높이는 스케줄링 기법 사용시 무기한 연기(Indefinite Postponement)와 같은 상황 방지 가능 

## 디스크 스케줄링 
### FCFS 스케줄링 
* FCFS(First Come First out) 스케줄링 기법: 디스크 입출력 요청들을 도착한 순서대로 서비스하는 기법 
    * 공평함(fair): 요청이 도착한 순서대로 서비스한다는 점 
    * 스케줄링으로 인한 오버헤드가 작음 : 디스크 입출력에 대한 부하가 작을 떄 적합한 기법 (디스크에 대한 I/O(Load)(일거리)가 적을때)
### SSTF 스케줄링
* SSTF(Shortest Seek Time First): 현재 헤드의 위치로부터 가장 가까운 요구를 먼저 서비스하는 것
    * 장점
        * 헤드가 이동해야하는 거리를 최소화 -> 단위시간 당 처리량(Throughput)을 극대화 가능 (FCFS보다 좋음)
        * 디스크 시스템에 대한 부하가 크지 않은 경우, 평균 응답 시간도 낮게 유지 가능 
    * 단점
        * 입출력 요구들에 대한 응답시간의 분산이 커짐 -> 응답 시간에 대한 예측성이 떨어짐 
        * 실제 시스템에서는 입출력 요구들이 시간이 지남에 따라 계속 도착 -> 부하가 커지는 경우 헤드가 특정 영역을 벗어나지 못하고 영역 안의 실린더들에 대한 요구들만을 계속 서비스 -> 헤드에서 먼 요구들에 대해서는 서비스하지 못하는 무기한 연기 현상이 발생 가능 (이를 제거하는 기법: SCAN 기법)
        * 일괄처리에서는 유용하나, 대화식 시스템에는 부적합 
### SCAN 스케줄링 
* SCAN 스케줄링 기법은 SSTF 기법처럼 현재 헤드와 가장 가까운 위치에 대한 요구를 먼저 서비스하지만 현재 헤드 진행 방향으로만 입출력 요구들을 처리함 -> 마지막 실린더 (양끝의 실린더)에 도착했을 때만 진행방향을 전환하여 나머지 요구들을 처리함 
* SSTF 기법을 사용했을 때 응답 시간에 대한 분산이 너무 커져서 응답시간의 예측성이 떨어진다는 단점을 해결
* 단위시간 당 처리량, 평균 응답 시간에 대해서도 우수함 
* 실제 디스크 시스템에서 사용되는 스케줄링 기법들의 근간을 이룸 
* 디스크 헤드가 진행하는 도중 헤드의 앞쪽에 추가로 다른 요청들이 도착하면 SCAN 기법은 이 요구들을 처리하면서 헤드를 계속 진행함
### LOOK 스케줄링
* 엘리베이터 알고리즘(Elevator Algorithm)이라고도 부름 
* SCAN 기법과 같은 방식으로 운영되나, 헤드가 진행하는 도중 진행 방향의 앞쪽으로 더 이상의 요구가 없으면 양끝의 실린더까지 진행하지 않고 그 자리에서 방향을 바꾸도록 함 (SCAN 기법의 단점을 해결)
* SCAN 기법과 LOOK 기법의 단점 3가지 
    1. 입출력 헤드 진행 방향의 앞쪽 방향에서 발생하면 즉시 서비스하지만 바로 뒤에서 발생하는 경우 입출력 헤드가 진행 방향의 끝까지 이동한 후에 다시 되돌아올 때까지 기다려야 한다는 특성을 가짐 
    2. 입출력 헤드의 진행 방향의 앞쪽으로 계속해서 디스크 접근 요구가 발생하는 경우 반대 방향의 요구들의 대기 시간은 계속 길어지게 됨 
    3. 양 끝에서 발생하는 입출력 요구는 디스크의 중앙 부분 실린더에서 발생하는 입출력 요구에 비해 서비스 기회를 적게 갖게됨 