# CHAP 06 (1)

## 퍼지 논리 
* fuzzy: "not clear, not distinct, or not precise; blurred"
* 명확하게 정의될 수 없는 지식으리 표현하는 방법
    * 애매한 논리는 x. 애매함을 다루는 질서정연한 논리임.
* 흔히 인간은 모호한 단어를 사용하여 문제를 해결하거나 지식을 표현함
### 명제논리와 퍼지논리
* 이진논리(부울논리)
    * 참과 거짓(1 or 0) - 흑백논리
* 퍼지논리
    * 0.0~1.0까지의 진리값을 가짐. (커질수록 확신이 커지는 것)
    * 지식표현의 애매성을 해결할 방법이 필요 (ex. 크다, 매우 크다, 매우매우 크다)
    * 퍼지명제나 규칙을 다루기 위한 퍼지논리로 발전 
### 퍼지논리와 집합
* 명제 논리 == 기존 집합(크리스프 집합)
* 퍼지 논리 == 퍼지 집합 
* 소속함수(Membership Funciton)
### 크리스프 집합 
* 기존의 집합이론
* 속하든지 그렇지 않다면 속하지 않은 것 
* 소속함수(Membership Function)으로 표현 
### 퍼지 집합
* 원소가 집합에 속하는 정도에 따라 소속함수값을 0~1 사이 값으로 대응
* 표기 방법 
    1. 비연속적인 퍼지 집합
    2. 연속적인 퍼지 집합
* 퍼지집합의 예 (ppt 참고)
* 연산자: NOT, AND, OR 등의 논리연산자 사용됨 
    * 퍼지집합은 기존의 크리스프 집합을 포함함.



## 추가 자료 
### 언어 변수와 헤지 
* 언어 변수 == 퍼지 변수 
    * "존은 크다"
        * 존: 언어변수 
        * 크다: 언어 값 ( 값의 범위 : 논의영역 )
* 헤지: 퍼지 집합 한정사의 개념을 수반 
    * 헤지 자신은 연산자처럼 작동함 
        * '매우'는 `집중 연산`을 수행하고 새로운 집합을 만듬
        * ex> 키가 큰 남자 집합에서 헤지 매우는 '매우 키가 큰 남자'라는 부분 집합을 이끌어냄 
        * '다소'는 `확장 연산`: 확장 연산은 집합을 확장함. 
        * ex> 다소 키가 큰 남자 집합에서 키가 큰 남자의 집합보다 범위가 넓음 
    * 연속체를 퍼지 구간으로 끊을 수 있음
    * 헤지를 사용하면 인간의 사고를 반영 가능 
    1. 매우 (very): 제곱
    2. 몹시 (extremely): 세제곱 
    3. 매우매우 (veryvery): 네제곱 
    4. 다소 (more or less): 확장 연산. 제곱근 
    5. 확실히 (indeed): 강화연산. 소속도가 0.5 이상이면 소속도 더 높이고, 0.5 이하면 더 낮춤 (ppt 참고)
### 퍼지 추론
* 맘다니형 추론 (Mamdani method) 
    1. 입력 변수 퍼지화
    2. 규칙 평가
        * 클리핑되거나 스케일링 된다 : 전체 면적의 20%를 스케일링 (기존의 면적은 20%를 넘을 수도 있어서 합칠 때 오차가 발생할 수 있으므로..)
    3. 출력으로 나온 규칙의 통합
    4. 역퍼지화 (하나의 크리스프한 값으로 내주자)
* 면적의 크기가 크면 무게중심 크게 나오고, 작으면 작게 나옴 

---

# CHAP 06(2)
## 계획(Planning)
* 주어진 과제를 해결하기 위해 매순간의 상태마다 행동을 취하기 이전에 미리 계획을 세워 보는 것이 신속하게 문제를 해결할 수 있음
* 상태공간에서 계획을 형식적으로 정의하면
    * `계획(plan)`: 임의의 상태 Si에서 목표 상태인 Sq에 도달하기 위한 순차적인 동작자들의 열(sequence)
    * `계획한다(planning)`: 이러한 계획을 탐색하는(찾아내는) 과정을 계획 
* 대표적인 계획 시스템인 `STRIPS(Standford Research Institute Problem Solver)`를 중심으로 계획과정을 설명함 
## STRIPS
* 블록세계의 상태들을 술어논리식에 의해 표현 (PPT 참고)
* 로봇이 취할 수 있는 행동을 동작자로 표현 (PPT 참고)
* 동작자들을 세 개의 `리스트`로 표현
    * `전제조건(precondition) 리스트`
        * 각 동작자는 이들이 적용 가능한 상태를 명시 
    * `삭제(deletion) 리스트`
    * `첨가(addition) 리스트` 

## STRIPS 알고리즘: Stack 이용
* 0단계: 현 상태를 초기상태로 둔다
* 1단계: 목표상태에서 참이 되는 술어들을 스택에 저장
* 2단계: 스택의 top에 저장된 술어에 대하여, 현 상태에서 만족되는지 여부를 검사
    * 만족되면 스택에서 `pop`. 이때 스택이 비게 되면 계획 종료
    * 만족되지 않으면 이 술어를 만족시킬 수 있는 `동작자`를 술어 대신에 `push`. 동작자의 전제조건을 새로운 목표상태(`subgoal`)로 하여 스택에 `push` 
* 3단계: 스택의 top에 저장된 원소가 동작자이면 이 동작자를 현 상태에 적용하여 새로운 상태를 생성. 이 새로운 상태를 현 상태로 둔다. -> 2단계로 되돌아간다 