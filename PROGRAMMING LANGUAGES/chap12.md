# CHAP 12

## 상속 (Inheritance)
* 기존 클래스로부터 새로운 클래스 유도 
* 자식 클래스는 부모 클래스의 필드, 메소드 상속하고 새로운 필드변수나 메소드 추가 가능
* 부모 클래스 = 기반 클래스 (base class) = 수퍼 클래스 (super class)
* 자식 클래스 = 유도 클래스 (derived class) = 서브 클래스 (subclass)
* `is-a 관계(relationship)`: 자식이 부모보다 구체적인 버전 
* 상속 장점: 소프트웨어 재사용(코드 재사용)

## Java에서의 상속 
* 단일 상속(single inheritance)만 지원: 하나의 슈퍼클래스로부터만 상속받을 수 있음 
### 메소드 재정의 overriding
* 자식클래스가 상속된 메소드를 자신이 원하는 대로 재정의할 수 있음 
* 새로운 메소드는 부모 메소드와 이름, 서명(signature)가 같아야함
* 메소드의 서명(signature): 메소드의 매개변수 이름, 개수, 순서, 타입이 같아야함 
* 재정의된 메소드 실행은 그 메소드를 실행하는 객체의 타입에 따라 호출될 메소드가 결정됨 
* 중복정의 vs. 메소드 재정의 
    * 중복정의: 한 클래스 내의 같은 이름의 여러개의 메소드, 상속과 관련 없음, 서로 다른 서명을 가진 경우
    * 메소드 재정의
### 다형 참조 
* ppt참조 
* 동적 바인딩: java는 동적 바인딩을 지원함 
    * 호출될 메소드는 참조 변수의 타입이 아니라 실행 시간에 참조되고 있는 객체의 타입에 의해 결정됨 
### 타입 캐스팅
* ppt 참고 

## 상속과 접근제어 
### 접근 조정자 (access modifier)
* 전용 (private) 가시성
    * 정의된 클래스 내에서만 접근 가능하고 자식 클래스에서 접근 불가능
* 공용 (public) 가시성
    * 캡슐화 원리를 위반
    * 자식 클래스 뿐만 아니라 프로그램 내 어디서나 접근 가능
* protected 가시성
    * 공용 가시성보다는 더 캡슐화하고 전용보다는 덜 캡슐화
    * 정의된 클래스 내와 그 자손 클래스에서 접근 가능 

## 추상 클래스(Abstract class)
* 추상 클래스: 포괄적인 개념을 표현하기 위한 클래스로 덜 구현됨. 추상 메소드 포함하고 있으면 추상 클래스임. 실체화될 수 없음. 완전히 구현된 메소드 포함해도 됨 
* 자식 클래스가 부모 클래스의 추상 메소드를 구현 (구현 안하면 여전히 추상클래스임) 
    * 추상 메소드는 final이나 static으로 선언하면 안됨
* 용도: 클래스 계층구조에서 실체화하기에 너무 포괄적인 공통요소들을 계층구조에 위치시킨다 

## C++
* public 상속 / private 상속 
* virtual 
* 다중 상속이 가능 -> 문제: 죽음의 다이아몬드 문제 -> 해결: 유효범위 해결 연산자(scope resolution operator) 

## python
* 다중상속이 가능 -> 해결: 메소드 탐색 순서(Method Resolution Order, MRO)에 따라 선택 

## 구현
* 객체는 구조체(레코드)처럼 메모리가 할당됨 (각 실체변수에 대한 메모리 할당)
* 동적 바인딩: 가상 메소드 테이블 이용 (각 객체는 이 테이블에 대한 포인터 가짐)
* 가상 메소드 테이블 
    * 메소드 테이블: 각 클래스마다 메소드 테이블 하나씩 있음. 클래스의 모든 가상 메소드는 하나의 인덱스 가짐. (인덱스 내용: 해당 메소드 코드의 주소) 
    * 메소드 호출 구현 
        * 대상 객체의 메소드 테이블 포인터 따라감
        * 해당 인덱스의 메소드 주소 따라감
        * 그 주소로 점프 
    * 서브클래스는 수퍼클래스의 메소드 테이블 상속받음, 메소드가 재정의되면 해당 메소드 테이블을 갱신함 